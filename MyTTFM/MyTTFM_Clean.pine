//@version=6
indicator("MyTTFM - Clean", "MyTTFM", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ==============================================
// INPUTS
// ==============================================

// General
fractalTimeframe = input.string("Automatic", "HTF Timeframe", options=["Automatic", "5m", "15m", "1H", "4H", "1D", "1W"])
maxHTFCandles = input.int(5, "Max HTF Candles", minval=1, maxval=20)

// HTF Candles
showHTFCandles = input.bool(true, "Show HTF Candles")
htfCandleOffset = input.int(10, "Candle Offset", minval=5, maxval=50)
htfCandleWidth = input.int(4, "Candle Width", minval=1, maxval=8)
htfCandleSpacing = input.int(2, "Candle Spacing", minval=1, maxval=5)
htfBullBodyColor = input.color(#089981, "Bull Body")
htfBearBodyColor = input.color(#000000, "Bear Body")
htfBorderColor = input.color(#000000, "Border Color")
htfWickColor = input.color(#000000, "Wick Color")

// Period Separators
showPeriodSeparators = input.bool(true, "Show Period Separators")
separatorColor = input.color(color.black, "Separator Color")
showSeparatorLabels = input.bool(false, "Show Period Labels")

// 50% Levels
show50Levels = input.bool(true, "Show 50% Levels")
fiftyLevelColor = input.color(#000000, "50% Level Color")

// T-Spot
showTSpot = input.bool(true, "Show T-Spot")
tSpotBullColor = input.color(color.new(color.green, 80), "T-Spot Bull Color")
tSpotBearColor = input.color(color.new(color.red, 80), "T-Spot Bear Color")

// C2/C3 Detection
showC2C3Detection = input.bool(true, "Show C2/C3 Detection")
maxC2C3Patterns = input.int(3, "Max C2/C3 Patterns", minval=1, maxval=10, tooltip="Maximum number of recent C2/C3 patterns to display")
c2LabelColor = input.color(color.black, "C2 Label Color")
c3LabelColor = input.color(color.black, "C3 Label Color")
showSweptLevels = input.bool(true, "Show Swept Levels")
sweptLevelColor = input.color(color.black, "Swept Level Color")

// Info
showInfoTable = input.bool(true, "Show Info Table")

// ==============================================
// TYPES
// ==============================================

type HTFCandle
    float o
    float h
    float l
    float c
    int openTime
    int openIdx
    int closeIdx
    int highIdx      // Bar index where the high was created
    int lowIdx       // Bar index where the low was created
    bool isComplete
    box candleBody
    line wickUp
    line wickDown

type SessionBoundary
    int barIndex
    int htfTime

type C2C3Pattern
    string patternType
    float sweptLevel
    bool isBullish
    int c1PeriodStart
    int c2PeriodEnd
    int c1HTFIndex        // Index of C1 HTF candle in array
    int c2HTFIndex        // Index of C2 HTF candle in array
    label patternLabel
    line chartTFLine      // Line on chart timeframe
    line htfCandleLine    // Line on HTF candles

type NextCandleBias
    int bias
    float targetLevel
    string biasReason
    bool isActive

// ==============================================
// GLOBALS
// ==============================================

var array<HTFCandle> htfCandles = array.new<HTFCandle>()
var array<SessionBoundary> sessionBoundaries = array.new<SessionBoundary>()
var array<C2C3Pattern> c2c3Patterns = array.new<C2C3Pattern>()
var NextCandleBias currentBias = NextCandleBias.new(bias=0, targetLevel=na, biasReason="", isActive=false)
var line fiftyLine = na
var label htfLabel = na
var box tSpotBox = na
var array<line> periodSeparatorLines = array.new<line>()
var array<label> periodSeparatorLabels = array.new<label>()

// ==============================================
// HELPER FUNCTIONS
// ==============================================

getHTFTimeframe() =>
    if fractalTimeframe == "Automatic"
        chartTF = timeframe.period
        switch
            chartTF == "1" => "15"
            chartTF == "3" => "30"
            chartTF == "5" => "60"
            chartTF == "15" => "240"
            chartTF == "30" => "240"
            chartTF == "60" => "1D"
            chartTF == "240" => "1W"
            chartTF == "1D" => "1M"
            => "240"
    else
        switch fractalTimeframe
            "5m" => "5"
            "15m" => "15"
            "1H" => "60"
            "4H" => "240"
            "1D" => "1D"
            "1W" => "1W"
            => "240"

getHTFDisplayName(tf) =>
    switch tf
        "5" => "5m"
        "15" => "15m"
        "30" => "30m"
        "60" => "1H"
        "240" => "4H"
        "1D" => "1D"
        "1W" => "1W"
        "1M" => "1M"
        => tf

safeGet(arr, index) =>
    if array.size(arr) > index and index >= 0
        array.get(arr, index)
    else
        na

cleanupOldCandles() =>
    while array.size(htfCandles) > maxHTFCandles
        oldCandle = array.pop(htfCandles)
        if not na(oldCandle)
            if not na(oldCandle.candleBody)
                box.delete(oldCandle.candleBody)
            if not na(oldCandle.wickUp)
                line.delete(oldCandle.wickUp)
            if not na(oldCandle.wickDown)
                line.delete(oldCandle.wickDown)

// C2 Detection: Sweep + Close Back
detectC2(current, previous) =>
    isC2 = false
    isBullish = false
    var float sweptLevel = na
    
    if not na(current) and not na(previous)
        // Bullish C2: sweep previous low + close back above that low
        if current.l < previous.l and current.c > previous.l
            isC2 := true
            isBullish := true
            sweptLevel := previous.l
        // Bearish C2: sweep previous high + close back below that high  
        else if current.h > previous.h and current.c < previous.h
            isC2 := true
            isBullish := false
            sweptLevel := previous.h
    
    [isC2, isBullish, sweptLevel]

// C3 Detection: Swing Point Formation + Directional Close
detectC3(current, previous, twoBarsAgo) =>
    isC3 = false
    isBullish = false
    var float sweptLevel = na
    
    if not na(current) and not na(previous) and not na(twoBarsAgo)
        // Bullish C3: previous candle forms swing low, current candle closes bullishly
        // Swing Low: previous.l < twoBarsAgo.l AND previous.l < current.l
        // Plus: current candle closes above previous candle's high (continuation)
        if previous.l < twoBarsAgo.l and previous.l < current.l and current.c > previous.h
            isC3 := true
            isBullish := true
            sweptLevel := previous.l
        // Bearish C3: previous candle forms swing high, current candle closes bearishly  
        // Swing High: previous.h > twoBarsAgo.h AND previous.h > current.h
        // Plus: current candle closes below previous candle's low (continuation)
        else if previous.h > twoBarsAgo.h and previous.h > current.h and current.c < previous.l
            isC3 := true
            isBullish := false
            sweptLevel := previous.h
    
    [isC3, isBullish, sweptLevel]

// Next Candle Model Bias
calculateBias(current, previous) =>
    bias = 0
    var float targetLevel = na
    biasReason = ""
    
    if not na(current) and not na(previous)
        if current.c > previous.h
            bias := 1
            targetLevel := previous.h
            biasReason := "Close Above PCH"
        else if current.c < previous.l
            bias := -1
            targetLevel := previous.l
            biasReason := "Close Below PCL"
        else if current.h > previous.h and current.c <= previous.h
            bias := -1
            targetLevel := previous.l
            biasReason := "Failed to displace above PCH"
        else if current.l < previous.l and current.c >= previous.l
            bias := 1
            targetLevel := previous.h
            biasReason := "Failed to displace below PCL"
        else
            bias := 0
            biasReason := current.h <= previous.h and current.l >= previous.l ? "Inside Bar" : "Outside Bar"
    
    [bias, targetLevel, biasReason]

// ==============================================
// MAIN LOGIC
// ==============================================

htfTimeframe = getHTFTimeframe()
htfTime = time(htfTimeframe)
isNewHTFPeriod = ta.change(htfTime) > 0

// Track session boundaries - immediate detection
if isNewHTFPeriod
    boundary = SessionBoundary.new(barIndex=bar_index, htfTime=htfTime)
    array.unshift(sessionBoundaries, boundary)
    while array.size(sessionBoundaries) > maxHTFCandles
        array.pop(sessionBoundaries)

// HTF Candle Management - immediate detection
if isNewHTFPeriod
    // Mark previous candle as complete
    if array.size(htfCandles) > 0
        lastCandle = safeGet(htfCandles, 0)
        if not na(lastCandle)
            lastCandle.isComplete := true
            array.set(htfCandles, 0, lastCandle)
    
    // Update all existing pattern HTF indices since array is shifting
    if array.size(c2c3Patterns) > 0
        for i = 0 to array.size(c2c3Patterns) - 1
            pattern = array.get(c2c3Patterns, i)
            if not na(pattern)
                // Increment indices because we're about to unshift a new candle
                pattern.c1HTFIndex := pattern.c1HTFIndex + 1
                pattern.c2HTFIndex := pattern.c2HTFIndex + 1
                array.set(c2c3Patterns, i, pattern)
    
    // Create new candle - ONLY set Open and initial values
    newCandle = HTFCandle.new(o=open, h=high, l=low, c=close, openTime=time, openIdx=bar_index, closeIdx=bar_index, highIdx=bar_index, lowIdx=bar_index, isComplete=false, candleBody=na, wickUp=na, wickDown=na)
    array.unshift(htfCandles, newCandle)
    cleanupOldCandles()

// Update current candle EVERY tick (real-time updates)
if array.size(htfCandles) > 0
    currentCandle = safeGet(htfCandles, 0)
    if not na(currentCandle)
        // Update High: take highest high in the HTF period and track which bar created it
        if high > currentCandle.h
            currentCandle.h := high
            currentCandle.highIdx := bar_index
        // Update Low: take lowest low in the HTF period and track which bar created it
        if low < currentCandle.l
            currentCandle.l := low
            currentCandle.lowIdx := bar_index
        // Update Close: always use current bar's close
        currentCandle.c := close
        currentCandle.closeIdx := bar_index
        array.set(htfCandles, 0, currentCandle)

// C2/C3 Pattern Detection - Trigger when new HTF period starts (previous candle just closed)
if isNewHTFPeriod and array.size(htfCandles) >= 2 and showC2C3Detection
    current = safeGet(htfCandles, 1)  // The just-completed HTF candle (now at index 1)
    previous = safeGet(htfCandles, 2)  // The previous completed HTF candle
    
    if not na(current) and not na(previous)
        // Calculate bias
        [bias, targetLevel, biasReason] = calculateBias(current, previous)
        currentBias.bias := bias
        currentBias.targetLevel := targetLevel
        currentBias.biasReason := biasReason
        currentBias.isActive := bias != 0
        
        // Detect C2: Sweep + Close Back
        [isC2, isBullishC2, c2SweptLevel] = detectC2(current, previous)
        if isC2
            // Simple label positioning - center of the completed HTF period
            completedBoundary = array.size(sessionBoundaries) >= 2 ? safeGet(sessionBoundaries, 1) : na
            if not na(completedBoundary)
                periodStartX = completedBoundary.barIndex
                periodEndX = bar_index
                labelX = math.round((periodStartX + periodEndX) / 2)
                
                // Simple label positioning - just above/below the current candle's high/low
                labelY = isBullishC2 ? (current.l - (current.h - current.l) * 0.1) : (current.h + (current.h - current.l) * 0.1)
                labelStyle = isBullishC2 ? label.style_label_up : label.style_label_down
                
                // Create C2 label
                c2Label = label.new(x=labelX, y=labelY, text="C2", color=color.new(color.white, 100), textcolor=c2LabelColor, style=labelStyle, size=size.normal)
                
                // Find the exact bar index where the swept level was created in C1 (previous HTF period)
                sweptBarIndex = isBullishC2 ? previous.lowIdx : previous.highIdx
                
                // Chart TF swept level line - from the bar that created the swept level to end of C2 session
                var line chartTFLine = na
                if showSweptLevels
                    chartTFLine := line.new(x1=sweptBarIndex, y1=c2SweptLevel, x2=bar_index, y2=c2SweptLevel, color=sweptLevelColor, style=line.style_solid, width=1)
                
                // Store the pattern with HTF candle indices
                c2Pattern = C2C3Pattern.new(patternType="C2", sweptLevel=c2SweptLevel, isBullish=isBullishC2, c1PeriodStart=sweptBarIndex, c2PeriodEnd=bar_index, c1HTFIndex=2, c2HTFIndex=1, patternLabel=c2Label, chartTFLine=chartTFLine, htfCandleLine=na)
                array.unshift(c2c3Patterns, c2Pattern)
    
    // Cleanup old patterns - use user-defined limit
    while array.size(c2c3Patterns) > maxC2C3Patterns
        oldPattern = array.pop(c2c3Patterns)
        if not na(oldPattern)
            if not na(oldPattern.patternLabel)
                label.delete(oldPattern.patternLabel)
            if not na(oldPattern.chartTFLine)
                line.delete(oldPattern.chartTFLine)
            if not na(oldPattern.htfCandleLine)
                line.delete(oldPattern.htfCandleLine)

// 50% Level Management
if show50Levels and array.size(htfCandles) >= 2 and showHTFCandles and barstate.islast
    previousCandle = safeGet(htfCandles, 1)
    if not na(previousCandle)
        fiftyLevel = (previousCandle.h + previousCandle.l) / 2
        candleCount = array.size(htfCandles)
        
        // Calculate positions
        previousPos = candleCount - 1 - 1
        currentPos = candleCount - 0 - 1
        startX = bar_index + htfCandleOffset + previousPos * (htfCandleWidth + htfCandleSpacing)
        endX = bar_index + htfCandleOffset + currentPos * (htfCandleWidth + htfCandleSpacing) + htfCandleWidth + htfCandleSpacing
        
        if not na(fiftyLine)
            line.delete(fiftyLine)
        fiftyLine := line.new(x1=startX, y1=fiftyLevel, x2=endX, y2=fiftyLevel, color=fiftyLevelColor, style=line.style_dotted, width=1)

// T-Spot Management (static rectangle for HTF period)
if showTSpot and array.size(htfCandles) >= 2 and barstate.islast
    currentCandle = safeGet(htfCandles, 0)  // Current HTF session (the one we're IN)
    previousCandle = safeGet(htfCandles, 1)  // Previous HTF session (just completed)
    
    if not na(currentCandle) and not na(previousCandle)
        // T-Spot: Current session open to Previous session 50%
        currentSessionOpen = currentCandle.o  // Open of current HTF session
        previousSession50 = (previousCandle.h + previousCandle.l) / 2  // 50% of previous HTF session
        
        // Only show T-Spot if there's actually a gap between open and previous 50%
        if currentSessionOpen != previousSession50
            // T-Spot direction based on Next Candle Model bias
            // PCH bias = bullish T-Spot (expecting 50% to support price higher)
            // PCL bias = bearish T-Spot (expecting 50% to reject price lower)
            isBullishTSpot = currentBias.bias > 0
            tSpotColor = isBullishTSpot ? tSpotBullColor : tSpotBearColor
            
            // T-Spot rectangle coordinates
            tSpotTop = math.max(currentSessionOpen, previousSession50)
            tSpotBottom = math.min(currentSessionOpen, previousSession50)
            tSpotLeft = currentCandle.openIdx  // Start of current HTF session
            
            // Calculate estimated session end based on HTF timeframe
            sessionDuration = switch htfTimeframe
                "5" => 5 * 60 * 1000
                "15" => 15 * 60 * 1000
                "30" => 30 * 60 * 1000
                "60" => 60 * 60 * 1000
                "240" => 240 * 60 * 1000
                "1D" => 24 * 60 * 60 * 1000
                "1W" => 7 * 24 * 60 * 60 * 1000
                => 240 * 60 * 1000
            
            estimatedCloseTime = currentCandle.openTime + sessionDuration
            barsDuration = math.max(20, math.round(sessionDuration / (timeframe.in_seconds() * 1000)))
            tSpotRight = currentCandle.openIdx + barsDuration
            
            // Delete old T-Spot box
            if not na(tSpotBox)
                box.delete(tSpotBox)
            
            // Create T-Spot rectangle
            tSpotBox := box.new(left=tSpotLeft, top=tSpotTop, right=tSpotRight, bottom=tSpotBottom, bgcolor=tSpotColor, border_color=color.new(tSpotColor, 50), border_width=1)

// HTF Candle Swept Level Lines Management - BOTH Chart TF AND HTF Lines
if showSweptLevels and showHTFCandles and array.size(c2c3Patterns) > 0 and array.size(htfCandles) > 0 and barstate.islast
    // Redraw ALL HTF candle lines every tick to keep them synchronized with HTF candle positions
    for i = 0 to math.min(array.size(c2c3Patterns) - 1, maxC2C3Patterns - 1)
        pattern = array.get(c2c3Patterns, i)
        if not na(pattern) and pattern.patternType == "C2"
            // Delete existing HTF line if it exists
            if not na(pattern.htfCandleLine)
                line.delete(pattern.htfCandleLine)
                pattern.htfCandleLine := na
            
            // Use the stored HTF candle indices (now properly maintained)
            c1HTFIndex = pattern.c1HTFIndex
            c2HTFIndex = pattern.c2HTFIndex
            
            candleCount = array.size(htfCandles)
            if candleCount > c1HTFIndex and candleCount > c2HTFIndex
                // Get the actual HTF candles
                c1Candle = array.get(htfCandles, c1HTFIndex)
                c2Candle = array.get(htfCandles, c2HTFIndex)
                
                if not na(c1Candle) and not na(c2Candle)
                    // Calculate HTF candle display positions (visual positions on chart)
                    c1CandlePos = candleCount - c1HTFIndex - 1
                    c2CandlePos = candleCount - c2HTFIndex - 1
                    
                    // Start: Center of C1 HTF candle (where the wick created the swept level)
                    c1CenterX = bar_index + htfCandleOffset + c1CandlePos * (htfCandleWidth + htfCandleSpacing) + htfCandleWidth / 2
                    
                    // End: Right edge of C2 HTF candle  
                    c2EndX = bar_index + htfCandleOffset + c2CandlePos * (htfCandleWidth + htfCandleSpacing) + htfCandleWidth
                    
                    // Create HTF candle line - use the actual swept level from pattern
                    htfLine = line.new(x1=c1CenterX, y1=pattern.sweptLevel, x2=c2EndX, y2=pattern.sweptLevel, color=sweptLevelColor, style=line.style_solid, width=1)
                    pattern.htfCandleLine := htfLine
                    array.set(c2c3Patterns, i, pattern)

// Period Separators
if showPeriodSeparators and array.size(sessionBoundaries) > 0 and barstate.islast
    // Clean up old period separator lines and labels
    while array.size(periodSeparatorLines) > 0
        oldLine = array.pop(periodSeparatorLines)
        if not na(oldLine)
            line.delete(oldLine)
    
    while array.size(periodSeparatorLabels) > 0
        oldLabel = array.pop(periodSeparatorLabels)
        if not na(oldLabel)
            label.delete(oldLabel)
    
    // Draw new period separators (dotted style)
    for i = 0 to array.size(sessionBoundaries) - 1
        boundary = array.get(sessionBoundaries, i)
        if not na(boundary)
            separatorLine = line.new(x1=boundary.barIndex, y1=high * 1.1, x2=boundary.barIndex, y2=low * 0.9, color=separatorColor, style=line.style_dotted, width=1, extend=extend.both)
            array.push(periodSeparatorLines, separatorLine)
            
            if showSeparatorLabels
                positionIndex = array.size(sessionBoundaries) - i
                labelText = htfTimeframe + " #" + str.tostring(positionIndex)
                separatorLabel = label.new(x=boundary.barIndex, y=low * 0.95, text=labelText, color=color.new(color.white, 100), textcolor=color.black, style=label.style_label_up, size=size.small)
                array.push(periodSeparatorLabels, separatorLabel)

// HTF Candle Rendering
if showHTFCandles and array.size(htfCandles) > 0 and barstate.islast
    candleCount = array.size(htfCandles)
    
    for i = candleCount - 1 to 0
        htfCandle = safeGet(htfCandles, i)
        if not na(htfCandle)
            positionIndex = candleCount - i - 1
            candleOffset = htfCandleOffset + positionIndex * (htfCandleWidth + htfCandleSpacing)
            
            // Delete existing objects
            if not na(htfCandle.candleBody)
                box.delete(htfCandle.candleBody)
            if not na(htfCandle.wickUp)
                line.delete(htfCandle.wickUp)
            if not na(htfCandle.wickDown)
                line.delete(htfCandle.wickDown)
            
            // Draw candle
            isBull = htfCandle.c >= htfCandle.o
            bodyColor = isBull ? htfBullBodyColor : htfBearBodyColor
            bodyTop = math.max(htfCandle.o, htfCandle.c)
            bodyBottom = math.min(htfCandle.o, htfCandle.c)
            leftX = bar_index + candleOffset
            rightX = leftX + htfCandleWidth
            
            htfCandle.candleBody := box.new(left=leftX, top=bodyTop, right=rightX, bottom=bodyBottom, bgcolor=bodyColor, border_color=htfBorderColor, border_width=1)
            
            wickX = leftX + htfCandleWidth / 2
            if htfCandle.h > bodyTop
                htfCandle.wickUp := line.new(x1=wickX, y1=htfCandle.h, x2=wickX, y2=bodyTop, color=htfWickColor, width=1)
            if htfCandle.l < bodyBottom
                htfCandle.wickDown := line.new(x1=wickX, y1=htfCandle.l, x2=wickX, y2=bodyBottom, color=htfWickColor, width=1)
            
            array.set(htfCandles, i, htfCandle)

// HTF Label
if showHTFCandles and barstate.islast and array.size(htfCandles) > 0
    if not na(htfLabel)
        label.delete(htfLabel)
    
    candleCount = array.size(htfCandles)
    totalWidth = candleCount * htfCandleWidth + (candleCount - 1) * htfCandleSpacing
    centerX = bar_index + htfCandleOffset + totalWidth / 2
    
    highestPoint = 0.0
    for i = 0 to candleCount - 1
        htfCandle = safeGet(htfCandles, i)
        if not na(htfCandle)
            highestPoint := math.max(highestPoint, htfCandle.h)
    
    // Calculate time remaining in current HTF period
    currentCandle = safeGet(htfCandles, 0)
    if not na(currentCandle)
        sessionDuration = switch htfTimeframe
            "5" => 5 * 60 * 1000
            "15" => 15 * 60 * 1000
            "30" => 30 * 60 * 1000
            "60" => 60 * 60 * 1000
            "240" => 240 * 60 * 1000
            "1D" => 24 * 60 * 60 * 1000
            "1W" => 7 * 24 * 60 * 60 * 1000
            => 240 * 60 * 1000
        
        timeRemaining = (currentCandle.openTime + sessionDuration - time) / 1000 / 60  // Minutes remaining
        htfDisplayName = getHTFDisplayName(htfTimeframe)
        
        var string timerText = ""
        if timeRemaining > 60
            hours = math.floor(timeRemaining / 60)
            minutes = math.floor(timeRemaining % 60)
            timerText := str.tostring(hours) + "h " + str.tostring(minutes) + "m"
        else
            timerText := str.tostring(math.floor(timeRemaining)) + "m"
        
        labelText = htfDisplayName + " (" + timerText + ")"
        htfLabel := label.new(centerX, highestPoint, labelText, color=color.new(color.white, 100), textcolor=color.black, style=label.style_label_down, size=size.normal)

// Info Table
if showInfoTable and barstate.islast
    infoTable = table.new(position=position.top_right, columns=2, rows=9, bgcolor=color.new(color.white, 90), border_width=1, border_color=color.gray)
    
    table.cell(infoTable, 0, 0, "Chart TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 0, timeframe.period, text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 1, "HTF TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 1, getHTFDisplayName(htfTimeframe), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "HTF Candles:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(array.size(htfCandles)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "C2/C3 Patterns:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(array.size(c2c3Patterns)), text_color=color.blue, text_size=size.small)
    
    // Debug: Show pattern types
    table.cell(infoTable, 0, 4, "Last Pattern:", text_color=color.black, text_size=size.small)
    lastPatternText = array.size(c2c3Patterns) > 0 ? array.get(c2c3Patterns, 0).patternType : "None"
    table.cell(infoTable, 1, 4, lastPatternText, text_color=color.orange, text_size=size.small)
    
    // Debug: Show last swept level value
    table.cell(infoTable, 0, 5, "Last Swept Level:", text_color=color.black, text_size=size.small)
    lastSweptLevel = array.size(c2c3Patterns) > 0 ? str.tostring(array.get(c2c3Patterns, 0).sweptLevel, "#.#####") : "None"
    table.cell(infoTable, 1, 5, lastSweptLevel, text_color=color.orange, text_size=size.small)
    
    // Debug: Show last HTF candle values
    table.cell(infoTable, 0, 6, "Last HTF H/L:", text_color=color.black, text_size=size.small)
    lastHTFCandle = array.size(htfCandles) > 1 ? array.get(htfCandles, 1) : na
    lastHTFValues = not na(lastHTFCandle) ? str.tostring(lastHTFCandle.h, "#.#####") + "/" + str.tostring(lastHTFCandle.l, "#.#####") : "None"
    table.cell(infoTable, 1, 6, lastHTFValues, text_color=color.orange, text_size=size.small)
    
    table.cell(infoTable, 0, 7, "Current Bias:", text_color=color.black, text_size=size.small)
    biasText = currentBias.isActive ? (currentBias.bias > 0 ? "PCH" : "PCL") : "None"
    biasColor = currentBias.isActive ? (currentBias.bias > 0 ? color.green : color.red) : color.gray
    table.cell(infoTable, 1, 7, biasText, text_color=biasColor, text_size=size.small)
    
    table.cell(infoTable, 0, 8, "Bias Reason:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 8, currentBias.biasReason, text_color=color.gray, text_size=size.small)
