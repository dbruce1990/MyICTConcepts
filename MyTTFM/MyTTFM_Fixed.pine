//@version=6
indicator("MyTTFM - HTF Candle Foundation", "MyTTFM", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ==================================================================================
// MyTTFM - Higher Timeframe Trading Foundation
// ==================================================================================
// Purpose: HTF candle rendering foundation for TTrades Fractal Model implementation
// Based on: Fadi HTF Candles + TTFMCopilot concepts
// Phase 1: HTF Candle Rendering with OHLC data access
// ==================================================================================

// Input Groups for organized settings
var string GROUP_GENERAL = "General Settings"
var string GROUP_HTF_CANDLES = "HTF Candles"
var string GROUP_PERIOD_SEPARATORS = "HTF Period Separators"
var string GROUP_VISUAL = "Visual Settings"
var string GROUP_INFO = "Info Table"

// ==================================================================================
// INPUT SETTINGS (Simplified for Phase 1)
// ==================================================================================

// General Settings
fractalTimeframe = input.string("Automatic", "HTF Timeframe", options=["Automatic", "5m", "15m", "1H", "4H", "1D", "1W"], group=GROUP_GENERAL, tooltip="Higher Timeframe for fractal analysis (auto-pairs with chart TF)")
maxHTFCandles = input.int(5, "Max HTF Candles", minval=1, maxval=20, group=GROUP_GENERAL, tooltip="Maximum number of HTF candles to display")

// HTF Candle Visual Settings
showHTFCandles = input.bool(true, "Show HTF Candles", group=GROUP_HTF_CANDLES, tooltip="Display HTF candles")
htfCandleOffset = input.int(10, "Candle Offset", minval=5, maxval=50, group=GROUP_HTF_CANDLES, tooltip="Offset from current price")
htfCandleWidth = input.int(4, "Candle Width", minval=1, maxval=8, group=GROUP_HTF_CANDLES, tooltip="Width of HTF candles")
htfCandleSpacing = input.int(2, "Candle Spacing", minval=1, maxval=5, group=GROUP_HTF_CANDLES, tooltip="Space between candles")

// Colors
htfBullBodyColor = input.color(#089981, "Bull Body", group=GROUP_HTF_CANDLES)
htfBearBodyColor = input.color(#000000, "Bear Body", group=GROUP_HTF_CANDLES)
htfBorderColor = input.color(#000000, "Border Color", group=GROUP_HTF_CANDLES)
htfWickColor = input.color(#000000, "Wick Color", group=GROUP_HTF_CANDLES)

// HTF Period Separators
showPeriodSeparators = input.bool(true, "Show Period Separators", group=GROUP_PERIOD_SEPARATORS, tooltip="Show vertical lines at HTF period boundaries")
separatorStyle = input.string("Dotted", "Separator Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_PERIOD_SEPARATORS)
separatorColor = input.color(color.black, "Separator Color", group=GROUP_PERIOD_SEPARATORS)
separatorWidth = input.int(1, "Separator Width", minval=1, maxval=3, group=GROUP_PERIOD_SEPARATORS)
showSeparatorLabels = input.bool(true, "Show Period Labels", group=GROUP_PERIOD_SEPARATORS, tooltip="Show HTF period start labels")
separatorLabelColor = input.color(color.black, "Period Label Color", group=GROUP_PERIOD_SEPARATORS)

// HTF 50% Levels
show50Levels = input.bool(true, "Show 50% Levels", group=GROUP_PERIOD_SEPARATORS, tooltip="Show 50% level of previous HTF candle")
fiftyLevelColor = input.color(#000000, "50% Level Color", group=GROUP_PERIOD_SEPARATORS)
fiftyLevelStyle = input.string("Dotted", "50% Level Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_PERIOD_SEPARATORS)
fiftyLevelWidth = input.int(1, "50% Level Width", minval=1, maxval=2, group=GROUP_PERIOD_SEPARATORS)

// C2/C3 Detection and Next Candle Model
var string GROUP_C2C3 = "C2/C3 Detection"
showC2C3Detection = input.bool(true, "Show C2/C3 Detection", group=GROUP_C2C3, tooltip="Detect and label C2/C3 patterns")
c2LabelColor = input.color(color.black, "C2 Label Color", group=GROUP_C2C3)
c3LabelColor = input.color(color.black, "C3 Label Color", group=GROUP_C2C3)
c2c3LabelSize = input.string(size.normal, "C2/C3 Label Size", options=[size.tiny, size.small, size.normal, size.large], group=GROUP_C2C3)
showSweptLevels = input.bool(true, "Show Swept Levels", group=GROUP_C2C3, tooltip="Show lines marking swept highs/lows")
sweptLevelColor = input.color(color.black, "Swept Level Color", group=GROUP_C2C3)
sweptLevelWidth = input.int(1, "Swept Level Width", minval=1, maxval=2, group=GROUP_C2C3)

// Labels and Information
showHTFLabels = input.bool(true, "Show HTF Labels", group=GROUP_VISUAL, tooltip="Show HTF timeframe labels")
htfLabelColor = input.color(color.black, "Label Color", group=GROUP_VISUAL)
htfLabelSize = input.string(size.normal, "Label Size", options=[size.tiny, size.small, size.normal, size.large, size.huge], group=GROUP_VISUAL)
showTimeRemaining = input.bool(true, "Show Time Remaining", group=GROUP_VISUAL, tooltip="Show time remaining in HTF period")
htfTimerColor = input.color(color.black, "Timer Color", group=GROUP_VISUAL)
htfTimerSize = input.string(size.small, "Timer Size", options=[size.tiny, size.small, size.normal, size.large], group=GROUP_VISUAL)

// Info Table
showInfoTable = input.bool(true, "Show Info Table", group=GROUP_INFO, tooltip="Show HTF information table")

// ==================================================================================
// TYPE DEFINITIONS (Based on Fadi structure, simplified)
// ==================================================================================

// HTF Candle Type
type HTFCandle
    float o         // Open price
    float h         // High price
    float l         // Low price
    float c         // Close price
    int openTime    // Opening time
    int openIdx     // Opening bar index
    int closeIdx    // Closing bar index
    int highIdx     // High bar index
    int lowIdx      // Low bar index
    bool isComplete // Whether candle is finished
    box candleBody  // Box for candle body
    line wickUp     // Upper wick line
    line wickDown   // Lower wick line

// HTF Candle Set (collection manager)
type HTFCandleSet
    array<HTFCandle> candles
    string timeframe
    int maxDisplay
    label tfLabel
    label timerLabel

// HTF Period Separator Type (for session boundaries)
type HTFPeriodSeparator
    line separatorLine
    label periodLabel
    int startBar
    bool isFuture  // Whether this is a future period boundary

// HTF Session Boundary Tracker
type HTFSessionBoundary
    int barIndex
    int htfTime
    bool isProcessed

// HTF 50% Level Type (for previous candle's 50% level)
type HTF50Level
    line fiftyPercentLine
    float level
    int sourceCandle  // Index of the HTF candle this level is based on

// C2/C3 Pattern Detection Types
type C2C3Pattern
    string patternType      // "C2" or "C3"
    int candleIndex        // Index in HTF candles array
    float sweptLevel       // The high/low that was swept
    bool isBullish         // Direction of the pattern
    label patternLabel     // Label showing C2/C3
    line sweptLevelLine    // Line marking the swept level
    int detectionBar       // Bar index where pattern was detected

// Next Candle Model Bias Tracker
type NextCandleBias
    int bias              // 1 = bullish (PCH), -1 = bearish (PCL), 0 = no bias
    float targetLevel     // The level we're biasing towards
    string biasReason     // Why this bias was assigned
    bool isActive         // Whether bias is still active

// ==================================================================================
// HELPER FUNCTIONS
// ==================================================================================

// Convert separator style string to line style
getSeparatorLineStyle() =>
    switch separatorStyle
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dashed

// Convert 50% level style string to line style
get50LevelLineStyle() =>
    switch fiftyLevelStyle
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dotted

// Calculate 50% level of an HTF candle (simple high/low midpoint)
calculate50Level(htfCandle) =>
    (htfCandle.h + htfCandle.l) / 2

// C2 Detection Logic (TTrades methodology)
detectC2Pattern(currentCandle, previousCandle) =>
    // C2 = Sweep + Close Inside
    // Current candle takes the high/low of previous candle but closes back inside previous candle's range
    var bool isC2 = false
    var bool isBullishC2 = false
    var float sweptLevel = na
    
    if not na(currentCandle) and not na(previousCandle)
        // Check for bullish C2 (sweep low, close back inside)
        if currentCandle.l < previousCandle.l and currentCandle.c > previousCandle.l and currentCandle.c < previousCandle.h
            isC2 := true
            isBullishC2 := true
            sweptLevel := previousCandle.l
        
        // Check for bearish C2 (sweep high, close back inside)
        else if currentCandle.h > previousCandle.h and currentCandle.c < previousCandle.h and currentCandle.c > previousCandle.l
            isC2 := true
            isBullishC2 := false
            sweptLevel := previousCandle.h
    
    [isC2, isBullishC2, sweptLevel]

// C3 Detection Logic (Swing Point Formation + Next Candle Model alignment)
detectC3Pattern(currentCandle, previousCandle, twoBarsAgo) =>
    // C3 = Swing Point Formation where current candle closes in direction of swing
    var bool isC3 = false
    var bool isBullishC3 = false
    var float sweptLevel = na
    
    if not na(currentCandle) and not na(previousCandle) and not na(twoBarsAgo)
        // Check for bullish C3 (swing low formation with bullish close)
        // Swing Low: previous candle's low < two bars ago low AND current candle's low > previous candle's low
        // Plus: current candle closes above previous candle's high (continuation)
        if previousCandle.l < twoBarsAgo.l and currentCandle.l > previousCandle.l and currentCandle.c > previousCandle.h
            isC3 := true
            isBullishC3 := true
            sweptLevel := previousCandle.l
        
        // Check for bearish C3 (swing high formation with bearish close)
        // Swing High: previous candle's high > two bars ago high AND current candle's high < previous candle's high
        // Plus: current candle closes below previous candle's low (continuation)
        else if previousCandle.h > twoBarsAgo.h and currentCandle.h < previousCandle.h and currentCandle.c < previousCandle.l
            isC3 := true
            isBullishC3 := false
            sweptLevel := previousCandle.h
    
    [isC3, isBullishC3, sweptLevel]

// Next Candle Model Bias Calculation (TTrades Daily Bias methodology)
calculateNextCandleBias(currentCandle, previousCandle) =>
    var int bias = 0
    var float targetLevel = na
    var string biasReason = ""
    
    if not na(currentCandle) and not na(previousCandle)
        // TTrades Mechanical Rules
        if currentCandle.c > previousCandle.h
            // Close above previous high ‚Üí bias previous high (continuation)
            bias := 1
            targetLevel := previousCandle.h
            biasReason := "Close Above PCH"
        else if currentCandle.c < previousCandle.l
            // Close below previous low ‚Üí bias previous low (continuation)
            bias := -1
            targetLevel := previousCandle.l
            biasReason := "Close Below PCL"
        else if currentCandle.h > previousCandle.h and currentCandle.c <= previousCandle.h
            // Failed to close above previous high ‚Üí bias previous low
            bias := -1
            targetLevel := previousCandle.l
            biasReason := "Failed PCH"
        else if currentCandle.l < previousCandle.l and currentCandle.c >= previousCandle.l
            // Failed to close below previous low ‚Üí bias previous high
            bias := 1
            targetLevel := previousCandle.h
            biasReason := "Failed PCL"
        else if currentCandle.h <= previousCandle.h and currentCandle.l >= previousCandle.l
            // Inside bar ‚Üí inherit previous direction (simplified)
            bias := 0
            biasReason := "Inside Bar"
        else
            // Outside bar ‚Üí no bias
            bias := 0
            biasReason := "Outside Bar"
    
    [bias, targetLevel, biasReason]

// Get automatic HTF timeframe based on chart timeframe
getAutoHTFTimeframe() =>
    chartTF = timeframe.period
    switch
        chartTF == "1" => "5"       // 1min -> 5min
        chartTF == "3" => "15"      // 3min -> 15min
        chartTF == "5" => "60"      // 5min -> 1hr
        chartTF == "15" => "240"    // 15min -> 4hr
        chartTF == "60" => "1D"     // 1hr -> Daily
        chartTF == "240" => "1W"    // 4hr -> Weekly
        chartTF == "1D" => "1M"     // Daily -> Monthly
        => "240"                    // Default fallback to 4hr

// Convert fractal setting to timeframe string
getFractalTimeframe() =>
    if fractalTimeframe == "Automatic"
        getAutoHTFTimeframe()
    else
        switch fractalTimeframe
            "5m" => "5"
            "15m" => "15"
            "1H" => "60"
            "4H" => "240"
            "1D" => "1D"
            "1W" => "1W"
            => "240"

// Calculate remaining time in HTF period
getRemainingTime(tf) =>
    if barstate.isrealtime
        timeRemaining = (time_close(tf) - timenow) / 1000
        hours = math.floor(timeRemaining / 3600)
        minutes = math.floor((timeRemaining - hours * 3600) / 60)
        timeText = str.tostring(hours) + "h " + str.tostring(minutes) + "m"
        timeText
    else
        "N/A"

// Safe array access with bounds checking
safeArrayGet(arr, index) =>
    if array.size(arr) > index and index >= 0
        array.get(arr, index)
    else
        na

// ==================================================================================
// GLOBAL VARIABLES
// ==================================================================================

// HTF Candle Set
var HTFCandleSet htfSet = HTFCandleSet.new(candles=array.new<HTFCandle>(), timeframe="", maxDisplay=maxHTFCandles, tfLabel=na, timerLabel=na)

// HTF Period Separators tracking
var array<HTFPeriodSeparator> periodSeparators = array.new<HTFPeriodSeparator>()

// HTF Session Boundaries tracking
var array<HTFSessionBoundary> sessionBoundaries = array.new<HTFSessionBoundary>()

// HTF 50% Levels tracking
var array<HTF50Level> fiftyLevels = array.new<HTF50Level>()

// C2/C3 Pattern tracking
var array<C2C3Pattern> c2c3Patterns = array.new<C2C3Pattern>()

// Next Candle Model bias tracking
var NextCandleBias currentBias = NextCandleBias.new(bias=0, targetLevel=na, biasReason="", isActive=false)

// Current HTF settings
htfTimeframe = getFractalTimeframe()
htfSet.timeframe := htfTimeframe
htfSet.maxDisplay := maxHTFCandles

// ==================================================================================
// HTF CANDLE DETECTION AND TRACKING
// ==================================================================================

// HTF period detection using time() function (Fadi's exact approach)
htfTime = time(htfTimeframe)
isNewHTFPeriod = ta.change(htfTime) > 0

// Track session boundaries when they occur
if isNewHTFPeriod and barstate.isconfirmed
    // Record this session boundary (start of new HTF period)
    boundary = HTFSessionBoundary.new(barIndex=bar_index, htfTime=htfTime, isProcessed=false)
    array.unshift(sessionBoundaries, boundary)
    
    // Keep only the boundaries we need for our HTF candles
    while array.size(sessionBoundaries) > maxHTFCandles
        array.pop(sessionBoundaries)

// HTF OHLC data
htfOpen = request.security(syminfo.tickerid, htfTimeframe, open, lookahead=barmerge.lookahead_off)
htfHigh = request.security(syminfo.tickerid, htfTimeframe, high, lookahead=barmerge.lookahead_off)
htfLow = request.security(syminfo.tickerid, htfTimeframe, low, lookahead=barmerge.lookahead_off)
htfClose = request.security(syminfo.tickerid, htfTimeframe, close, lookahead=barmerge.lookahead_off)

// ==================================================================================
// HTF CANDLE MANAGEMENT
// ==================================================================================

// Create new HTF candle when new period starts using CURRENT BAR data (Fadi's approach)
if isNewHTFPeriod and barstate.isconfirmed
    // Mark the previous candle as complete if it exists
    if array.size(htfSet.candles) > 0
        lastCandle = safeArrayGet(htfSet.candles, 0)  // Current candle is at index 0
        if not na(lastCandle)
            lastCandle.isComplete := true
            array.set(htfSet.candles, 0, lastCandle)
    
    // Create new HTF candle with CURRENT BAR data (this starts the new HTF period)
    newCandle = HTFCandle.new(o=open, h=high, l=low, c=close, openTime=time, openIdx=bar_index, closeIdx=bar_index, highIdx=bar_index, lowIdx=bar_index, isComplete=false, candleBody=na, wickUp=na, wickDown=na)
    
    // Add to FRONT of array like Fadi (newest first: right to left in array)
    array.unshift(htfSet.candles, newCandle)
    
    // Clean up old candles (remove from end)
    while array.size(htfSet.candles) > htfSet.maxDisplay
        oldCandle = array.pop(htfSet.candles)
        if not na(oldCandle) and not na(oldCandle.candleBody)
            box.delete(oldCandle.candleBody)
        if not na(oldCandle) and not na(oldCandle.wickUp)
            line.delete(oldCandle.wickUp)
        if not na(oldCandle) and not na(oldCandle.wickDown)
            line.delete(oldCandle.wickDown)

// Update current HTF candle with CURRENT BAR data (progressive updates like Fadi)
if array.size(htfSet.candles) > 0 and barstate.isconfirmed
    currentCandle = safeArrayGet(htfSet.candles, 0)
    if not na(currentCandle)
        // Update high if current bar's high is higher
        if high > currentCandle.h
            currentCandle.h := high
            currentCandle.highIdx := bar_index
        
        // Update low if current bar's low is lower
        if low < currentCandle.l
            currentCandle.l := low
            currentCandle.lowIdx := bar_index
        
        // Always update close and close index (like Fadi)
        currentCandle.c := close
        currentCandle.closeIdx := bar_index
        
        // Update the candle in array (first position)
        array.set(htfSet.candles, 0, currentCandle)

// ==================================================================================
// C2/C3 PATTERN DETECTION AND NEXT CANDLE MODEL
// ==================================================================================

// Detect C2/C3 patterns and calculate Next Candle Model bias when HTF period completes
if isNewHTFPeriod and barstate.isconfirmed and array.size(htfSet.candles) >= 2 and showC2C3Detection
    // Get the candles we need for pattern detection
    currentCandle = safeArrayGet(htfSet.candles, 1)  // Previous period (just completed)
    previousCandle = safeArrayGet(htfSet.candles, 2) // The candle before that
    twoBarsAgo = safeArrayGet(htfSet.candles, 3)     // For C3 swing detection
    
    if not na(currentCandle) and not na(previousCandle)
        // Calculate Next Candle Model bias
        [bias, targetLevel, biasReason] = calculateNextCandleBias(currentCandle, previousCandle)
        currentBias.bias := bias
        currentBias.targetLevel := targetLevel
        currentBias.biasReason := biasReason
        currentBias.isActive := bias != 0
        
        // Detect C2 pattern
        [isC2, isBullishC2, c2SweptLevel] = detectC2Pattern(currentCandle, previousCandle)
        
        // Detect C3 pattern
        [isC3, isBullishC3, c3SweptLevel] = detectC3Pattern(currentCandle, previousCandle, twoBarsAgo)
        
        // Variable for swept level lines
        var line sweptLine = na
        
        // Process C2 detection
        if isC2
            // Find the session boundary for this completed HTF period
            completedBoundary = HTFSessionBoundary.new(barIndex=na, htfTime=na, isProcessed=na)
            if array.size(sessionBoundaries) >= 2
                completedBoundary := safeArrayGet(sessionBoundaries, 1) // Previous boundary (completed period)
            
            if not na(completedBoundary)
                // Calculate label position between period separators
                periodStartX = completedBoundary.barIndex
                periodEndX = bar_index  // Current bar (start of new period)
                labelX = math.round((periodStartX + periodEndX) / 2)
                
                // Position label above highest high (bearish) or below lowest low (bullish)
                var float labelY = na
                var string labelStyle = label.style_label_up
                if isBullishC2
                    labelY := currentCandle.l * 0.998  // Below the low
                    labelStyle := label.style_label_up
                else
                    labelY := currentCandle.h * 1.002  // Above the high
                    labelStyle := label.style_label_down
                
                // Create C2 label
                c2Label = label.new(x=labelX, y=labelY, text="C2", color=color.new(color.white, 100), textcolor=c2LabelColor, style=labelStyle, size=c2c3LabelSize)
                
                // Create swept level line if enabled
                sweptLine = na
                if showSweptLevels
                    sweptLine := line.new(x1=periodStartX, y1=c2SweptLevel, x2=periodEndX, y2=c2SweptLevel, color=sweptLevelColor, style=line.style_solid, width=sweptLevelWidth)
                
                // Create and store C2 pattern
                c2Pattern = C2C3Pattern.new(patternType="C2", candleIndex=1, sweptLevel=c2SweptLevel, isBullish=isBullishC2, patternLabel=c2Label, sweptLevelLine=sweptLine, detectionBar=bar_index)
                array.unshift(c2c3Patterns, c2Pattern)
        
        // Process C3 detection
        if isC3
            // Find the session boundary for this completed HTF period
            completedBoundary = HTFSessionBoundary.new(barIndex=na, htfTime=na, isProcessed=na)
            if array.size(sessionBoundaries) >= 2
                completedBoundary := safeArrayGet(sessionBoundaries, 1) // Previous boundary (completed period)
            
            if not na(completedBoundary)
                // Calculate label position between period separators
                periodStartX = completedBoundary.barIndex
                periodEndX = bar_index  // Current bar (start of new period)
                labelX = math.round((periodStartX + periodEndX) / 2)
                
                // Position label above highest high (bearish) or below lowest low (bullish)
                var float labelY = na
                var string labelStyle = label.style_label_up
                if isBullishC3
                    labelY := currentCandle.l * 0.995  // Below the low
                    labelStyle := label.style_label_up
                else
                    labelY := currentCandle.h * 1.005  // Above the high
                    labelStyle := label.style_label_down
                
                // Create C3 label
                c3Label = label.new(x=labelX, y=labelY, text="C3", color=color.new(color.white, 100), textcolor=c3LabelColor, style=labelStyle, size=c2c3LabelSize)
                
                // Create swept level line if enabled
                sweptLine = na
                if showSweptLevels
                    sweptLine := line.new(x1=periodStartX, y1=c3SweptLevel, x2=periodEndX, y2=c3SweptLevel, color=sweptLevelColor, style=line.style_solid, width=sweptLevelWidth)
                
                // Create and store C3 pattern
                c3Pattern = C2C3Pattern.new(patternType="C3", candleIndex=1, sweptLevel=c3SweptLevel, isBullish=isBullishC3, patternLabel=c3Label, sweptLevelLine=sweptLine, detectionBar=bar_index)
                array.unshift(c2c3Patterns, c3Pattern)
    
    // Clean up old patterns (keep only what we can display)
    while array.size(c2c3Patterns) > maxHTFCandles * 2  // Allow for both C2 and C3 per candle
        oldPattern = array.pop(c2c3Patterns)
        if not na(oldPattern)
            if not na(oldPattern.patternLabel)
                label.delete(oldPattern.patternLabel)
            if not na(oldPattern.sweptLevelLine)
                line.delete(oldPattern.sweptLevelLine)

// ==================================================================================
// HTF 50% LEVEL MANAGEMENT (Fixed for Left-to-Right Rendering)
// ==================================================================================

// Render 50% level for the previous HTF candle (only when HTF candles are visible)
if show50Levels and array.size(htfSet.candles) >= 2 and showHTFCandles and barstate.islast
    // Get the previous candle (second in array: index 1)
    previousCandleIndex = 1
    previousCandle = safeArrayGet(htfSet.candles, previousCandleIndex)
    
    if not na(previousCandle)
        // Calculate 50% level
        fiftyLevel = calculate50Level(previousCandle)
        
        // Calculate position using Fadi's exact formula: (size - i - 1)
        candleCount = array.size(htfSet.candles)
        previousCandlePositionIndex = candleCount - previousCandleIndex - 1
        previousCandleOffset = htfCandleOffset + previousCandlePositionIndex * (htfCandleWidth + htfCandleSpacing)
        startX = bar_index + previousCandleOffset
        
        // Calculate the end position (1 candle width past the current HTF candle)
        currentCandleIndex = 0  // Current candle is at index 0
        currentCandlePositionIndex = candleCount - currentCandleIndex - 1
        currentCandleOffset = htfCandleOffset + currentCandlePositionIndex * (htfCandleWidth + htfCandleSpacing)
        endX = bar_index + currentCandleOffset + htfCandleWidth + htfCandleSpacing
        
        // Clean up old 50% level line if it exists
        while array.size(fiftyLevels) > 0
            old50Level = array.pop(fiftyLevels)
            if not na(old50Level) and not na(old50Level.fiftyPercentLine)
                line.delete(old50Level.fiftyPercentLine)
        
        // Create 50% level line from previous candle position to 1 candle past current position
        fiftyLine = line.new(x1=startX, y1=fiftyLevel, x2=endX, y2=fiftyLevel, color=fiftyLevelColor, style=get50LevelLineStyle(), width=fiftyLevelWidth)
        
        // Create 50% level object and add to tracking array
        new50Level = HTF50Level.new(fiftyPercentLine=fiftyLine, level=fiftyLevel, sourceCandle=previousCandleIndex)
        array.push(fiftyLevels, new50Level)

// ==================================================================================
// HTF PERIOD SEPARATORS MANAGEMENT (Session Boundaries + 1 Future)
// ==================================================================================

// Render period separators using tracked session boundaries
if showPeriodSeparators and array.size(sessionBoundaries) > 0 and barstate.islast
    // Clean up all existing separators first
    while array.size(periodSeparators) > 0
        oldSeparator = array.pop(periodSeparators)
        if not na(oldSeparator) and not na(oldSeparator.separatorLine)
            line.delete(oldSeparator.separatorLine)
        if not na(oldSeparator) and not na(oldSeparator.periodLabel)
            label.delete(oldSeparator.periodLabel)
    
    boundaryCount = array.size(sessionBoundaries)
    
    // Create separators for each session boundary (from oldest to newest)
    for i = boundaryCount - 1 to 0
        boundary = array.get(sessionBoundaries, i)
        if not na(boundary)
            // Use the actual bar index where this session boundary occurred
            separatorX = boundary.barIndex
            
            // Create separator line at the actual chart bar where HTF session started
            separatorLine = line.new(x1=separatorX, y1=high * 1.1, x2=separatorX, y2=low * 0.9, color=separatorColor, style=getSeparatorLineStyle(), width=separatorWidth, extend=extend.both)
            
            // Create period label if enabled
            var label periodLabel = na
            if showSeparatorLabels
                positionIndex = boundaryCount - i - 1  // For numbering left to right (oldest = 1, newest = highest)
                labelText = htfTimeframe + " #" + str.tostring(positionIndex + 1)
                periodLabel := label.new(x=separatorX, y=low * 0.95, text=labelText, color=color.new(color.white, 100), textcolor=separatorLabelColor, style=label.style_label_up, size=size.small)
            
            // Create separator object and add to tracking array
            separator = HTFPeriodSeparator.new(separatorLine=separatorLine, periodLabel=periodLabel, startBar=separatorX, isFuture=false)
            array.push(periodSeparators, separator)

// ==================================================================================
// HTF CANDLE RENDERING (Fixed: Left to Right Order - Oldest to Newest)
// ==================================================================================

if showHTFCandles and array.size(htfSet.candles) > 0
    // Calculate positioning
    baseOffset = htfCandleOffset
    candleCount = array.size(htfSet.candles)
    
    // Render each HTF candle (Fadi's exact approach: iterate backwards for left-to-right display)
    for i = candleCount - 1 to 0
        htfCandle = safeArrayGet(htfSet.candles, i)
        if not na(htfCandle)
            // Calculate position using Fadi's exact formula: (size - i - 1)
            // This ensures: oldest candle (i=size-1) gets position 0 (leftmost)
            //              newest candle (i=0) gets position size-1 (rightmost)
            positionIndex = candleCount - i - 1
            candleOffset = baseOffset + positionIndex * (htfCandleWidth + htfCandleSpacing)
            
            // Delete existing drawing objects
            if not na(htfCandle.candleBody)
                box.delete(htfCandle.candleBody)
            if not na(htfCandle.wickUp)
                line.delete(htfCandle.wickUp)
            if not na(htfCandle.wickDown)
                line.delete(htfCandle.wickDown)
            
            // Determine candle color
            isBull = htfCandle.c >= htfCandle.o
            bodyColor = isBull ? htfBullBodyColor : htfBearBodyColor
            
            // Calculate body coordinates
            bodyTop = math.max(htfCandle.o, htfCandle.c)
            bodyBottom = math.min(htfCandle.o, htfCandle.c)
            leftX = bar_index + candleOffset
            rightX = bar_index + candleOffset + htfCandleWidth
            
            // Draw candle body
            htfCandle.candleBody := box.new(left=leftX, top=bodyTop, right=rightX, bottom=bodyBottom, bgcolor=bodyColor, border_color=htfBorderColor, border_width=1)
            
            // Calculate wick positions
            wickX = leftX + htfCandleWidth / 2
            
            // Draw upper wick (if exists)
            if htfCandle.h > bodyTop
                htfCandle.wickUp := line.new(x1=wickX, y1=htfCandle.h, x2=wickX, y2=bodyTop, color=htfWickColor, width=1)
            
            // Draw lower wick (if exists)
            if htfCandle.l < bodyBottom
                htfCandle.wickDown := line.new(x1=wickX, y1=htfCandle.l, x2=wickX, y2=bodyBottom, color=htfWickColor, width=1)
            
            // Update candle in array
            array.set(htfSet.candles, i, htfCandle)

// ==================================================================================
// LABELS AND INFORMATION
// ==================================================================================

if showHTFLabels and barstate.islast and array.size(htfSet.candles) > 0
    // Delete existing labels
    if not na(htfSet.tfLabel)
        label.delete(htfSet.tfLabel)
    if not na(htfSet.timerLabel)
        label.delete(htfSet.timerLabel)
    
    // Calculate center position using Fadi's exact approach
    candleCount = array.size(htfSet.candles)
    totalWidth = candleCount * htfCandleWidth + (candleCount - 1) * htfCandleSpacing
    centerX = bar_index + htfCandleOffset + totalWidth / 2
    
    // Find highest point of ALL HTF candles (like Fadi's CandlesHigh method)
    highestPoint = 0.0
    for i = 0 to candleCount - 1
        htfCandle = safeArrayGet(htfSet.candles, i)
        if not na(htfCandle)
            highestPoint := math.max(highestPoint, htfCandle.h)
    
    // Use Fadi's multi-line label approach to prevent overlapping
    labelText = htfTimeframe
    if showTimeRemaining
        timerText = getRemainingTime(htfTimeframe)
        labelText := labelText + "\n(" + timerText + ")"
    
    // Single label with multi-line text (Fadi's approach)
    htfSet.tfLabel := label.new(centerX, highestPoint, labelText, color=color.new(color.white, 100), textcolor=htfLabelColor, style=label.style_label_down, size=htfLabelSize)

// ==================================================================================
// INFO TABLE
// ==================================================================================

if showInfoTable and barstate.islast
    // Create info table
    infoTable = table.new(position=position.top_right, columns=2, rows=11, bgcolor=color.new(color.white, 90), border_width=1, border_color=color.gray)
    
    // Table content
    table.cell(infoTable, 0, 0, "Chart TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 0, timeframe.period, text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 1, "HTF TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 1, htfTimeframe, text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "HTF Candles:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(array.size(htfSet.candles)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "Period Separators:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(array.size(periodSeparators)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 4, "50% Levels:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 4, str.tostring(array.size(fiftyLevels)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 5, "C2/C3 Patterns:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(array.size(c2c3Patterns)), text_color=color.blue, text_size=size.small)
    
    // Next Candle Model Bias
    table.cell(infoTable, 0, 6, "Current Bias:", text_color=color.black, text_size=size.small)
    biasText = currentBias.isActive ? (currentBias.bias > 0 ? "PCH" : "PCL") : "None"
    biasColor = currentBias.isActive ? (currentBias.bias > 0 ? color.green : color.red) : color.gray
    table.cell(infoTable, 1, 6, biasText, text_color=biasColor, text_size=size.small)
    
    table.cell(infoTable, 0, 7, "Bias Reason:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 7, currentBias.biasReason, text_color=color.gray, text_size=size.small)
    
    // HTF OHLC Data
    table.cell(infoTable, 0, 8, "HTF Open:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 8, str.tostring(htfOpen, "#.####"), text_color=color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 9, "HTF High:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 9, str.tostring(htfHigh, "#.####"), text_color=color.green, text_size=size.small)
    
    table.cell(infoTable, 0, 10, "HTF Low:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 10, str.tostring(htfLow, "#.####"), text_color=color.red, text_size=size.small)

// ==================================================================================
// PHASE 1 COMPLETION NOTES + PHASE 2 IMPLEMENTATION
// ==================================================================================
// ‚úÖ HTF CANDLE FOUNDATION COMPLETE:
//
// üéØ PHASE 1 IMPLEMENTED FEATURES:
// - HTF period detection using time() function (corrected timing alignment)
// - HTF OHLC data access and tracking
// - HTF candle rendering with proper left-to-right positioning
// - Automatic timeframe pairing (chart TF -> HTF TF)
// - Manual timeframe selection override
// - HTF candle visual customization (colors, sizing, spacing)
// - HTF candle management (creation, updating, cleanup)
// - Real-time updates with proper barstate handling
// - HTF Period separators with session boundary tracking
// - HTF 50% levels for previous candle positioning
// - Info table with HTF OHLC data display
// - Time remaining calculation for HTF periods
//
// üéØ PHASE 2 IMPLEMENTED FEATURES:
// - C2 Pattern Detection: Sweep + Close Inside logic
// - C3 Pattern Detection: Swing Point Formation + Next Candle Model alignment
// - Next Candle Model: TTrades Daily Bias methodology (PCH/PCL bias calculation)
// - C2/C3 Labels: Positioned between period separators above/below extremes
// - Swept Level Lines: Black solid lines marking the high/low that was swept
// - Pattern Tracking: Complete C2/C3 pattern management with cleanup
// - Bias Tracking: Current bias display in info table with reasoning
//
// üîß TECHNICAL FEATURES:
// - Type-safe C2/C3 pattern data structures
// - Next Candle Model bias calculation engine
// - Pattern detection using HTF candle completion events
// - Smart label positioning between session boundaries
// - Swept level line rendering with proper period alignment
// - Memory management with automatic pattern cleanup
// - Pine Script v6 compliance (named parameters, proper indentation)
// - Drawing object limits management
//
// üìä C2/C3 DETECTION LOGIC:
// - C2: Current HTF candle sweeps previous HTF candle high/low but closes back inside range
// - C3: Swing point formation where current candle closes in direction of swing
// - Next Candle Model: Statistical bias based on close vs previous high/low
// - Pattern Labels: Positioned at midpoint between period separators
// - Swept Levels: Lines from period start to period end marking swept price
//
// üöÄ READY FOR PHASE 3:
// The foundation now includes TTrades Fractal Model core components:
// - CISD (Change in State of Delivery) detection
// - Point of Interest (POI) context filtering
// - Multi-timeframe alignment validation
// - Statistical tracking and success rate monitoring
// - Advanced pattern filtering and confirmation
//
// üìù USAGE:
// This indicator now provides both HTF candle foundation AND C2/C3 pattern detection
// with Next Candle Model bias calculation. Labels appear between period separators
// showing C2 (black) and C3 (black) patterns, with black lines marking swept levels.
// The info table displays current bias (PCH/PCL) and reasoning.
//
// The C2/C3 detection follows TTrades methodology:
// - C2 = Sweep previous high/low + close back inside (reversal setup)
// - C3 = Swing point formation + directional close (continuation setup)
// - Next Candle Model = Statistical bias for next HTF candle direction
// ==================================================================================
