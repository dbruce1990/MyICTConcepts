//@version=6
indicator("MyTTFM - HTF Candle Foundation", "MyTTFM", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ==================================================================================
// MyTTFM - Higher Timeframe Trading Foundation
// ==================================================================================
// Purpose: HTF candle rendering foundation for TTrades Fractal Model implementation
// Based on: Fadi HTF Candles + TTFMCopilot concepts
// Phase 1: HTF Candle Rendering with OHLC data access
// ==================================================================================

// Input Groups for organized settings
var string GROUP_GENERAL = "General Settings"
var string GROUP_HTF_CANDLES = "HTF Candles"
var string GROUP_PERIOD_SEPARATORS = "HTF Period Separators"
var string GROUP_VISUAL = "Visual Settings"
var string GROUP_INFO = "Info Table"

// ==================================================================================
// INPUT SETTINGS (Simplified for Phase 1)
// ==================================================================================

// General Settings
fractalTimeframe = input.string("Automatic", "HTF Timeframe", options=["Automatic", "5m", "15m", "1H", "4H", "1D", "1W"], group=GROUP_GENERAL, tooltip="Higher Timeframe for fractal analysis (auto-pairs with chart TF)")
maxHTFCandles = input.int(5, "Max HTF Candles", minval=1, maxval=20, group=GROUP_GENERAL, tooltip="Maximum number of HTF candles to display")

// HTF Candle Visual Settings
showHTFCandles = input.bool(true, "Show HTF Candles", group=GROUP_HTF_CANDLES, tooltip="Display HTF candles")
htfCandleOffset = input.int(10, "Candle Offset", minval=5, maxval=50, group=GROUP_HTF_CANDLES, tooltip="Offset from current price")
htfCandleWidth = input.int(4, "Candle Width", minval=1, maxval=8, group=GROUP_HTF_CANDLES, tooltip="Width of HTF candles")
htfCandleSpacing = input.int(2, "Candle Spacing", minval=1, maxval=5, group=GROUP_HTF_CANDLES, tooltip="Space between candles")

// Colors
htfBullBodyColor = input.color(#089981, "Bull Body", group=GROUP_HTF_CANDLES)
htfBearBodyColor = input.color(#000000, "Bear Body", group=GROUP_HTF_CANDLES)
htfBorderColor = input.color(#000000, "Border Color", group=GROUP_HTF_CANDLES)
htfWickColor = input.color(#000000, "Wick Color", group=GROUP_HTF_CANDLES)

// HTF Period Separators
showPeriodSeparators = input.bool(true, "Show Period Separators", group=GROUP_PERIOD_SEPARATORS, tooltip="Show vertical lines at HTF period boundaries")
separatorStyle = input.string("Dotted", "Separator Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_PERIOD_SEPARATORS)
separatorColor = input.color(color.black, "Separator Color", group=GROUP_PERIOD_SEPARATORS)
separatorWidth = input.int(1, "Separator Width", minval=1, maxval=3, group=GROUP_PERIOD_SEPARATORS)
showSeparatorLabels = input.bool(true, "Show Period Labels", group=GROUP_PERIOD_SEPARATORS, tooltip="Show HTF period start labels")
separatorLabelColor = input.color(color.black, "Period Label Color", group=GROUP_PERIOD_SEPARATORS)

// HTF 50% Levels
show50Levels = input.bool(true, "Show 50% Levels", group=GROUP_PERIOD_SEPARATORS, tooltip="Show 50% level of previous HTF candle")
fiftyLevelColor = input.color(#000000, "50% Level Color", group=GROUP_PERIOD_SEPARATORS)
fiftyLevelStyle = input.string("Dotted", "50% Level Style", options=["Solid", "Dashed", "Dotted"], group=GROUP_PERIOD_SEPARATORS)
fiftyLevelWidth = input.int(1, "50% Level Width", minval=1, maxval=2, group=GROUP_PERIOD_SEPARATORS)

// Labels and Information
showHTFLabels = input.bool(true, "Show HTF Labels", group=GROUP_VISUAL, tooltip="Show HTF timeframe labels")
htfLabelColor = input.color(color.black, "Label Color", group=GROUP_VISUAL)
htfLabelSize = input.string(size.normal, "Label Size", options=[size.tiny, size.small, size.normal, size.large, size.huge], group=GROUP_VISUAL)
showTimeRemaining = input.bool(true, "Show Time Remaining", group=GROUP_VISUAL, tooltip="Show time remaining in HTF period")
htfTimerColor = input.color(color.black, "Timer Color", group=GROUP_VISUAL)
htfTimerSize = input.string(size.small, "Timer Size", options=[size.tiny, size.small, size.normal, size.large], group=GROUP_VISUAL)

// Info Table
showInfoTable = input.bool(true, "Show Info Table", group=GROUP_INFO, tooltip="Show HTF information table")

// ==================================================================================
// TYPE DEFINITIONS (Based on Fadi structure, simplified)
// ==================================================================================

// HTF Candle Type
type HTFCandle
    float o         // Open price
    float h         // High price
    float l         // Low price
    float c         // Close price
    int openTime    // Opening time
    int openIdx     // Opening bar index
    int closeIdx    // Closing bar index
    int highIdx     // High bar index
    int lowIdx      // Low bar index
    bool isComplete // Whether candle is finished
    box candleBody  // Box for candle body
    line wickUp     // Upper wick line
    line wickDown   // Lower wick line

// HTF Candle Set (collection manager)
type HTFCandleSet
    array<HTFCandle> candles
    string timeframe
    int maxDisplay
    label tfLabel
    label timerLabel

// HTF Period Separator Type (for session boundaries)
type HTFPeriodSeparator
    line separatorLine
    label periodLabel
    int startBar
    bool isFuture  // Whether this is a future period boundary

// HTF Session Boundary Tracker
type HTFSessionBoundary
    int barIndex
    int htfTime
    bool isProcessed

// HTF 50% Level Type (for previous candle's 50% level)
type HTF50Level
    line fiftyPercentLine
    float level
    int sourceCandle  // Index of the HTF candle this level is based on

// ==================================================================================
// HELPER FUNCTIONS
// ==================================================================================

// Convert separator style string to line style
getSeparatorLineStyle() =>
    switch separatorStyle
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dashed

// Convert 50% level style string to line style
get50LevelLineStyle() =>
    switch fiftyLevelStyle
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dotted

// Calculate 50% level of an HTF candle (simple high/low midpoint)
calculate50Level(htfCandle) =>
    (htfCandle.h + htfCandle.l) / 2

// Get automatic HTF timeframe based on chart timeframe
getAutoHTFTimeframe() =>
    chartTF = timeframe.period
    switch
        chartTF == "1" => "5"       // 1min -> 5min
        chartTF == "3" => "15"      // 3min -> 15min
        chartTF == "5" => "60"      // 5min -> 1hr
        chartTF == "15" => "240"    // 15min -> 4hr
        chartTF == "60" => "1D"     // 1hr -> Daily
        chartTF == "240" => "1W"    // 4hr -> Weekly
        chartTF == "1D" => "1M"     // Daily -> Monthly
        => "240"                    // Default fallback to 4hr

// Convert fractal setting to timeframe string
getFractalTimeframe() =>
    if fractalTimeframe == "Automatic"
        getAutoHTFTimeframe()
    else
        switch fractalTimeframe
            "5m" => "5"
            "15m" => "15"
            "1H" => "60"
            "4H" => "240"
            "1D" => "1D"
            "1W" => "1W"
            => "240"

// Calculate remaining time in HTF period
getRemainingTime(tf) =>
    if barstate.isrealtime
        timeRemaining = (time_close(tf) - timenow) / 1000
        hours = math.floor(timeRemaining / 3600)
        minutes = math.floor((timeRemaining - hours * 3600) / 60)
        timeText = str.tostring(hours) + "h " + str.tostring(minutes) + "m"
        timeText
    else
        "N/A"

// Safe array access with bounds checking
safeArrayGet(arr, index) =>
    if array.size(arr) > index and index >= 0
        array.get(arr, index)
    else
        na

// ==================================================================================
// GLOBAL VARIABLES
// ==================================================================================

// HTF Candle Set
var HTFCandleSet htfSet = HTFCandleSet.new(candles=array.new<HTFCandle>(), timeframe="", maxDisplay=maxHTFCandles, tfLabel=na, timerLabel=na)

// HTF Period Separators tracking
var array<HTFPeriodSeparator> periodSeparators = array.new<HTFPeriodSeparator>()

// HTF Session Boundaries tracking
var array<HTFSessionBoundary> sessionBoundaries = array.new<HTFSessionBoundary>()

// HTF 50% Levels tracking
var array<HTF50Level> fiftyLevels = array.new<HTF50Level>()

// Current HTF settings
htfTimeframe = getFractalTimeframe()
htfSet.timeframe := htfTimeframe
htfSet.maxDisplay := maxHTFCandles

// ==================================================================================
// HTF CANDLE DETECTION AND TRACKING
// ==================================================================================

// HTF period detection using time() function (Fadi's exact approach)
htfTime = time(htfTimeframe)
isNewHTFPeriod = ta.change(htfTime) > 0

// Track session boundaries when they occur
if isNewHTFPeriod and barstate.isconfirmed
    // Record this session boundary (start of new HTF period)
    boundary = HTFSessionBoundary.new(barIndex=bar_index, htfTime=htfTime, isProcessed=false)
    array.unshift(sessionBoundaries, boundary)
    
    // Keep only the boundaries we need for our HTF candles
    while array.size(sessionBoundaries) > maxHTFCandles
        array.pop(sessionBoundaries)

// HTF OHLC data
htfOpen = request.security(syminfo.tickerid, htfTimeframe, open, lookahead=barmerge.lookahead_off)
htfHigh = request.security(syminfo.tickerid, htfTimeframe, high, lookahead=barmerge.lookahead_off)
htfLow = request.security(syminfo.tickerid, htfTimeframe, low, lookahead=barmerge.lookahead_off)
htfClose = request.security(syminfo.tickerid, htfTimeframe, close, lookahead=barmerge.lookahead_off)

// ==================================================================================
// HTF CANDLE MANAGEMENT
// ==================================================================================

// Create new HTF candle when new period starts using CURRENT BAR data (Fadi's approach)
if isNewHTFPeriod and barstate.isconfirmed
    // Mark the previous candle as complete if it exists
    if array.size(htfSet.candles) > 0
        lastCandle = safeArrayGet(htfSet.candles, 0)  // Current candle is at index 0
        if not na(lastCandle)
            lastCandle.isComplete := true
            array.set(htfSet.candles, 0, lastCandle)
    
    // Create new HTF candle with CURRENT BAR data (this starts the new HTF period)
    newCandle = HTFCandle.new(o=open, h=high, l=low, c=close, openTime=time, openIdx=bar_index, closeIdx=bar_index, highIdx=bar_index, lowIdx=bar_index, isComplete=false, candleBody=na, wickUp=na, wickDown=na)
    
    // Add to FRONT of array like Fadi (newest first: right to left in array)
    array.unshift(htfSet.candles, newCandle)
    
    // Clean up old candles (remove from end)
    while array.size(htfSet.candles) > htfSet.maxDisplay
        oldCandle = array.pop(htfSet.candles)
        if not na(oldCandle) and not na(oldCandle.candleBody)
            box.delete(oldCandle.candleBody)
        if not na(oldCandle) and not na(oldCandle.wickUp)
            line.delete(oldCandle.wickUp)
        if not na(oldCandle) and not na(oldCandle.wickDown)
            line.delete(oldCandle.wickDown)

// Update current HTF candle with CURRENT BAR data (progressive updates like Fadi)
if array.size(htfSet.candles) > 0 and barstate.isconfirmed
    currentCandle = safeArrayGet(htfSet.candles, 0)
    if not na(currentCandle)
        // Update high if current bar's high is higher
        if high > currentCandle.h
            currentCandle.h := high
            currentCandle.highIdx := bar_index
        
        // Update low if current bar's low is lower
        if low < currentCandle.l
            currentCandle.l := low
            currentCandle.lowIdx := bar_index
        
        // Always update close and close index (like Fadi)
        currentCandle.c := close
        currentCandle.closeIdx := bar_index
        
        // Update the candle in array (first position)
        array.set(htfSet.candles, 0, currentCandle)

// ==================================================================================
// HTF 50% LEVEL MANAGEMENT (Fixed for Left-to-Right Rendering)
// ==================================================================================

// Render 50% level for the previous HTF candle (only when HTF candles are visible)
if show50Levels and array.size(htfSet.candles) >= 2 and showHTFCandles and barstate.islast
    // Get the previous candle (second in array: index 1)
    previousCandleIndex = 1
    previousCandle = safeArrayGet(htfSet.candles, previousCandleIndex)
    
    if not na(previousCandle)
        // Calculate 50% level
        fiftyLevel = calculate50Level(previousCandle)
        
        // Calculate position using Fadi's exact formula: (size - i - 1)
        candleCount = array.size(htfSet.candles)
        previousCandlePositionIndex = candleCount - previousCandleIndex - 1
        previousCandleOffset = htfCandleOffset + previousCandlePositionIndex * (htfCandleWidth + htfCandleSpacing)
        startX = bar_index + previousCandleOffset
        
        // Calculate the end position (1 candle width past the current HTF candle)
        currentCandleIndex = 0  // Current candle is at index 0
        currentCandlePositionIndex = candleCount - currentCandleIndex - 1
        currentCandleOffset = htfCandleOffset + currentCandlePositionIndex * (htfCandleWidth + htfCandleSpacing)
        endX = bar_index + currentCandleOffset + htfCandleWidth + htfCandleSpacing
        
        // Clean up old 50% level line if it exists
        while array.size(fiftyLevels) > 0
            old50Level = array.pop(fiftyLevels)
            if not na(old50Level) and not na(old50Level.fiftyPercentLine)
                line.delete(old50Level.fiftyPercentLine)
        
        // Create 50% level line from previous candle position to 1 candle past current position
        fiftyLine = line.new(x1=startX, y1=fiftyLevel, x2=endX, y2=fiftyLevel, color=fiftyLevelColor, style=get50LevelLineStyle(), width=fiftyLevelWidth)
        
        // Create 50% level object and add to tracking array
        new50Level = HTF50Level.new(fiftyPercentLine=fiftyLine, level=fiftyLevel, sourceCandle=previousCandleIndex)
        array.push(fiftyLevels, new50Level)

// ==================================================================================
// HTF PERIOD SEPARATORS MANAGEMENT (Session Boundaries + 1 Future)
// ==================================================================================

// Render period separators using tracked session boundaries
if showPeriodSeparators and array.size(sessionBoundaries) > 0 and barstate.islast
    // Clean up all existing separators first
    while array.size(periodSeparators) > 0
        oldSeparator = array.pop(periodSeparators)
        if not na(oldSeparator) and not na(oldSeparator.separatorLine)
            line.delete(oldSeparator.separatorLine)
        if not na(oldSeparator) and not na(oldSeparator.periodLabel)
            label.delete(oldSeparator.periodLabel)
    
    boundaryCount = array.size(sessionBoundaries)
    
    // Create separators for each session boundary (from oldest to newest)
    for i = boundaryCount - 1 to 0
        boundary = array.get(sessionBoundaries, i)
        if not na(boundary)
            // Use the actual bar index where this session boundary occurred
            separatorX = boundary.barIndex
            
            // Create separator line at the actual chart bar where HTF session started
            separatorLine = line.new(x1=separatorX, y1=high * 1.1, x2=separatorX, y2=low * 0.9, color=separatorColor, style=getSeparatorLineStyle(), width=separatorWidth, extend=extend.both)
            
            // Create period label if enabled
            var label periodLabel = na
            if showSeparatorLabels
                positionIndex = boundaryCount - i - 1  // For numbering left to right (oldest = 1, newest = highest)
                labelText = htfTimeframe + " #" + str.tostring(positionIndex + 1)
                periodLabel := label.new(x=separatorX, y=low * 0.95, text=labelText, color=color.new(color.white, 100), textcolor=separatorLabelColor, style=label.style_label_up, size=size.small)
            
            // Create separator object and add to tracking array
            separator = HTFPeriodSeparator.new(separatorLine=separatorLine, periodLabel=periodLabel, startBar=separatorX, isFuture=false)
            array.push(periodSeparators, separator)

// ==================================================================================
// HTF CANDLE RENDERING (Fixed: Left to Right Order - Oldest to Newest)
// ==================================================================================

if showHTFCandles and array.size(htfSet.candles) > 0
    // Calculate positioning
    baseOffset = htfCandleOffset
    candleCount = array.size(htfSet.candles)
    
    // Render each HTF candle (Fadi's exact approach: iterate backwards for left-to-right display)
    for i = candleCount - 1 to 0
        htfCandle = safeArrayGet(htfSet.candles, i)
        if not na(htfCandle)
            // Calculate position using Fadi's exact formula: (size - i - 1)
            // This ensures: oldest candle (i=size-1) gets position 0 (leftmost)
            //              newest candle (i=0) gets position size-1 (rightmost)
            positionIndex = candleCount - i - 1
            candleOffset = baseOffset + positionIndex * (htfCandleWidth + htfCandleSpacing)
            
            // Delete existing drawing objects
            if not na(htfCandle.candleBody)
                box.delete(htfCandle.candleBody)
            if not na(htfCandle.wickUp)
                line.delete(htfCandle.wickUp)
            if not na(htfCandle.wickDown)
                line.delete(htfCandle.wickDown)
            
            // Determine candle color
            isBull = htfCandle.c >= htfCandle.o
            bodyColor = isBull ? htfBullBodyColor : htfBearBodyColor
            
            // Calculate body coordinates
            bodyTop = math.max(htfCandle.o, htfCandle.c)
            bodyBottom = math.min(htfCandle.o, htfCandle.c)
            leftX = bar_index + candleOffset
            rightX = bar_index + candleOffset + htfCandleWidth
            
            // Draw candle body
            htfCandle.candleBody := box.new(left=leftX, top=bodyTop, right=rightX, bottom=bodyBottom, bgcolor=bodyColor, border_color=htfBorderColor, border_width=1)
            
            // Calculate wick positions
            wickX = leftX + htfCandleWidth / 2
            
            // Draw upper wick (if exists)
            if htfCandle.h > bodyTop
                htfCandle.wickUp := line.new(x1=wickX, y1=htfCandle.h, x2=wickX, y2=bodyTop, color=htfWickColor, width=1)
            
            // Draw lower wick (if exists)
            if htfCandle.l < bodyBottom
                htfCandle.wickDown := line.new(x1=wickX, y1=htfCandle.l, x2=wickX, y2=bodyBottom, color=htfWickColor, width=1)
            
            // Update candle in array
            array.set(htfSet.candles, i, htfCandle)

// ==================================================================================
// LABELS AND INFORMATION
// ==================================================================================

if showHTFLabels and barstate.islast and array.size(htfSet.candles) > 0
    // Delete existing labels
    if not na(htfSet.tfLabel)
        label.delete(htfSet.tfLabel)
    if not na(htfSet.timerLabel)
        label.delete(htfSet.timerLabel)
    
    // Calculate center position using Fadi's exact approach
    candleCount = array.size(htfSet.candles)
    totalWidth = candleCount * htfCandleWidth + (candleCount - 1) * htfCandleSpacing
    centerX = bar_index + htfCandleOffset + totalWidth / 2
    
    // Find highest point of ALL HTF candles (like Fadi's CandlesHigh method)
    highestPoint = 0.0
    for i = 0 to candleCount - 1
        htfCandle = safeArrayGet(htfSet.candles, i)
        if not na(htfCandle)
            highestPoint := math.max(highestPoint, htfCandle.h)
    
    // Use Fadi's multi-line label approach to prevent overlapping
    labelText = htfTimeframe
    if showTimeRemaining
        timerText = getRemainingTime(htfTimeframe)
        labelText := labelText + "\n(" + timerText + ")"
    
    // Single label with multi-line text (Fadi's approach)
    htfSet.tfLabel := label.new(centerX, highestPoint, labelText, color=color.new(color.white, 100), textcolor=htfLabelColor, style=label.style_label_down, size=htfLabelSize)

// ==================================================================================
// INFO TABLE
// ==================================================================================

if showInfoTable and barstate.islast
    // Create info table
    infoTable = table.new(position=position.top_right, columns=2, rows=8, bgcolor=color.new(color.white, 90), border_width=1, border_color=color.gray)
    
    // Table content
    table.cell(infoTable, 0, 0, "Chart TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 0, timeframe.period, text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 1, "HTF TF:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 1, htfTimeframe, text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "HTF Candles:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(array.size(htfSet.candles)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "Period Separators:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(array.size(periodSeparators)), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 4, "50% Levels:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 4, str.tostring(array.size(fiftyLevels)), text_color=color.blue, text_size=size.small)
    
    // HTF OHLC Data
    table.cell(infoTable, 0, 5, "HTF Open:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(htfOpen, "#.####"), text_color=color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 6, "HTF High:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 6, str.tostring(htfHigh, "#.####"), text_color=color.green, text_size=size.small)
    
    table.cell(infoTable, 0, 7, "HTF Low:", text_color=color.black, text_size=size.small)
    table.cell(infoTable, 1, 7, str.tostring(htfLow, "#.####"), text_color=color.red, text_size=size.small)

// ==================================================================================
// PHASE 1 COMPLETION NOTES
// ==================================================================================
// ✅ HTF CANDLE FOUNDATION COMPLETE:
//
// 🎯 IMPLEMENTED FEATURES:
// - HTF period detection using request.security
// - HTF OHLC data access and tracking
// - HTF candle rendering with proper positioning
// - Automatic timeframe pairing (chart TF -> HTF TF)
// - Manual timeframe selection override
// - HTF candle visual customization (colors, sizing, spacing)
// - HTF candle management (creation, updating, cleanup)
// - Real-time updates with proper barstate handling
// - Info table with HTF OHLC data display
// - Time remaining calculation for HTF periods
//
// 🔧 TECHNICAL FEATURES:
// - Type-safe HTF candle data structure
// - Array-based candle set management
// - Safe array access with bounds checking
// - Memory management with automatic cleanup
// - Pine Script v6 compliance (named parameters, proper indentation)
// - Drawing object limits management
//
// 🚀 READY FOR PHASE 2:
// The foundation is now ready to add TTFMCopilot features:
// - Swing point detection within HTF context
// - Next Candle Model bias calculation
// - C2/C3/C4 pattern detection
// - CISD (Change in State of Delivery) tracking
// - Period separators
// - Statistical tracking and validation
//
// 📝 USAGE:
// This indicator provides the essential HTF candle rendering foundation
// that matches the Fadi HTF Candles functionality while being structured
// for easy integration of TTrades Fractal Model concepts.
//
// The HTF OHLC data is accessible and properly tracked, providing the
// foundation for implementing bias calculations, swing point detection,
// and pattern recognition in future phases.
// ==================================================================================
