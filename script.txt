//@version=6
indicator("ICT Cursor", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500, max_bars_back=5000)

// === SWING POINT TYPE & ARRAYS ===
type SwingPoint
    int xBar
    int xTime
    float y
    string state // "active", "swept", "closed_through"
    int sweepX
    int closedX
    line lineDrawing = na

var swingHighs = array.new<SwingPoint>()
var swingLows = array.new<SwingPoint>()

// === SWING POINT SETTINGS ===
inputGroupSwings = "Swing Point Settings"
showActiveSwings = input.bool(true, "Show Active Swings", group=inputGroupSwings, tooltip="Show swing points that have not been swept or closed through.")
showSweptSwings = input.bool(true, "Show Swept Swings", group=inputGroupSwings, tooltip="Show swing points that have been swept (wicked through) but not closed through.")
maxSweptSwings = input.int(5, "Max Swept Swings", minval=1, maxval=20, group=inputGroupSwings, tooltip="Maximum number of swept swings to display.")
showClosedSwings = input.bool(false, "Show Closed-Through Swings", group=inputGroupSwings, tooltip="Show swing points that have been closed through (break of structure). Useful for market structure analysis.")
maxClosedSwings = input.int(3, "Max Closed Swings", minval=1, maxval=20, group=inputGroupSwings, tooltip="Maximum number of closed-through swings to display.")
activeHighColor = input.color(color.black, "Active High Color", group=inputGroupSwings, tooltip="Color for active swing high lines.")
activeLowColor = input.color(color.black, "Active Low Color", group=inputGroupSwings, tooltip="Color for active swing low lines.")
sweptHighColor = input.color(color.black, "Swept High Color", group=inputGroupSwings, tooltip="Color for swept swing high lines.")
sweptLowColor = input.color(color.black, "Swept Low Color", group=inputGroupSwings, tooltip="Color for swept swing low lines.")
closedHighColor = input.color(#616161, "Closed High Color", group=inputGroupSwings, tooltip="Color for closed-through swing high lines.")
closedLowColor = input.color(#616161, "Closed Low Color", group=inputGroupSwings, tooltip="Color for closed-through swing low lines.")
activeSwingStyle = input.string("solid", "Active Swing Style", options=["solid", "dashed"], group=inputGroupSwings, tooltip="Line style for active swings.")
sweptSwingStyle = input.string("dashed", "Swept Swing Style", options=["solid", "dashed"], group=inputGroupSwings, tooltip="Line style for swept swings.")
closedSwingStyle = input.string("dotted", "Closed-Through Swing Style", options=["solid", "dashed", "dotted"], group=inputGroupSwings, tooltip="Line style for closed-through swings.")
maxSwingPoints = input.int(100, "Max Swing Points Stored", minval=20, maxval=500, group=inputGroupSwings, tooltip="Maximum number of swing points to keep in memory. Older points will be removed for performance.")
lookbackBars = input.int(500, "Bars to Display", minval=50, maxval=5000, group=inputGroupSwings, tooltip="Only show swing points from the last N bars.")

// === BULLETPROOF ARRAY CAPPING ===
while array.size(swingHighs) > maxSwingPoints
    swing = array.shift(swingHighs)
    if not na(swing.lineDrawing)
        line.delete(swing.lineDrawing)
while array.size(swingLows) > maxSwingPoints
    swing = array.shift(swingLows)
    if not na(swing.lineDrawing)
        line.delete(swing.lineDrawing)

// === SWING DETECTION (3-bar pivots) ===
if barstate.isconfirmed
    // Highs
    if high[1] > high[0] and high[1] > high[2]
        swing = SwingPoint.new()
        swing.y := high[1]
        swing.xTime := time[1]
        swing.xBar := bar_index[1]
        swing.state := "active"
        swing.sweepX := na
        swing.closedX := na
        array.push(swingHighs, swing)
    // Lows
    if low[1] < low[0] and low[1] < low[2]
        swing = SwingPoint.new()
        swing.y := low[1]
        swing.xTime := time[1]
        swing.xBar := bar_index[1]
        swing.state := "active"
        swing.sweepX := na
        swing.closedX := na
        array.push(swingLows, swing)

// === SWING RENDERING ===
renderSwings(array<SwingPoint> swings, bool isHigh) =>
    if array.size(swings) > 0
        sweptIdx = array.new_int()
        closedIdx = array.new_int()
        for i = 0 to array.size(swings) - 1
            swing = array.get(swings, i)
            // Only process/display if within lookback window
            if bar_index - swing.xBar > lookbackBars
                if not na(swing.lineDrawing)
                    line.delete(swing.lineDrawing)
                continue
            // Update state
            if swing.state == "active"
                swept = isHigh ? high > swing.y : low < swing.y
                closed = isHigh ? close > swing.y : close < swing.y
                if swept
                    swing.state := "swept"
                    swing.sweepX := bar_index
                if closed
                    swing.state := "closed_through"
                    swing.closedX := bar_index
                array.set(swings, i, swing)
            if swing.state == "swept"
                closed = isHigh ? close > swing.y : close < swing.y
                if closed
                    swing.state := "closed_through"
                    swing.closedX := bar_index
                    array.set(swings, i, swing)
            // Collect indices for visible swept/closed
            if swing.state == "swept"
                array.push(sweptIdx, i)
            if swing.state == "closed_through"
                array.push(closedIdx, i)
        // Cap swept/closed shown (for display only)
        sweptToShow = array.size(sweptIdx) > maxSweptSwings ? array.slice(sweptIdx, array.size(sweptIdx) - maxSweptSwings, array.size(sweptIdx)) : sweptIdx
        closedToShow = array.size(closedIdx) > maxClosedSwings ? array.slice(closedIdx, array.size(closedIdx) - maxClosedSwings, array.size(closedIdx)) : closedIdx
        for i = 0 to array.size(swings) - 1
            swing = array.get(swings, i)
            if bar_index - swing.xBar > lookbackBars
                if not na(swing.lineDrawing)
                    line.delete(swing.lineDrawing)
                continue
            showLine = false
            lineColor = color(na)
            style = line.style_solid
            // Color and style by state and high/low
            if swing.state == "active" and showActiveSwings
                showLine := true
                lineColor := isHigh ? activeHighColor : activeLowColor
                style := activeSwingStyle == "dashed" ? line.style_dashed : line.style_solid
            if swing.state == "swept" and showSweptSwings and array.includes(sweptToShow, i)
                showLine := true
                lineColor := isHigh ? sweptHighColor : sweptLowColor
                style := sweptSwingStyle == "dashed" ? line.style_dashed : line.style_solid
            if swing.state == "closed_through" and showClosedSwings and array.includes(closedToShow, i)
                showLine := true
                lineColor := isHigh ? closedHighColor : closedLowColor
                style := closedSwingStyle == "dashed" ? line.style_dashed : closedSwingStyle == "dotted" ? line.style_dotted : line.style_solid
            if showLine
                x2 = swing.state == "active" ? bar_index : swing.state == "swept" ? swing.sweepX : swing.closedX
                if na(swing.lineDrawing)
                    swing.lineDrawing := line.new(x1=swing.xBar, y1=swing.y, x2=x2, y2=swing.y, color=lineColor, width=1, extend=extend.none, style=style)
                else
                    line.set_x2(swing.lineDrawing, x2)
                    line.set_style(swing.lineDrawing, style)
                    line.set_color(swing.lineDrawing, lineColor)
                array.set(swings, i, swing)
            else
                if not na(swing.lineDrawing)
                    line.delete(swing.lineDrawing)
                    swing.lineDrawing := na
                    array.set(swings, i, swing)

if showActiveSwings or showSweptSwings or showClosedSwings
    renderSwings(swingHighs, true)
    renderSwings(swingLows, false)

// === SETTINGS: FAIR VALUE GAPS (FVG) ===
inputGroupFVG = "Fair Value Gap (FVG) Settings"
showFVG = input.bool(true, "Show FVGs", group=inputGroupFVG, tooltip="Toggle the display of Fair Value Gaps (FVG) on the chart.")
redrawFVGUnbalancedArea = input.bool(false, "Adjust FVG to Remaining Imbalance?", group=inputGroupFVG, tooltip="If enabled, the FVG box will shrink as price fills the imbalance, showing only the remaining unbalanced area.")
removeMitigatedFVGDrawings = input.bool(true, "Remove Balanced FVGs", group=inputGroupFVG, tooltip="If enabled, FVG boxes will be removed from the chart once they are fully balanced (mitigated).")
fvgColor = input.color(#2962FF, "FVG Color", group=inputGroupFVG, tooltip="Color for Fair Value Gap boxes.")
var int maxImbalances = 200

// === FVG TYPE & ARRAYS ===
type FVG
    int xLow
    int xHigh
    int xLowTime
    int xHighTime
    float yLow
    float yHigh
    int mitigatedTime
    float unmitigatedY = 0.0
    bool mitigated = false
    box fvgBox = na

var FVG[] BISIs = array.new<FVG>()
var FVG[] SIBIs = array.new<FVG>()

// === FVG HELPERS ===
cleanupFVGs(array<FVG> fvgArray) =>
    while array.size(fvgArray) > maxImbalances
        fvg = array.shift(fvgArray)
        if not na(fvg.fvgBox)
            box.delete(fvg.fvgBox)

renderFVGs(array<FVG> fvgs, color boxColor, bool isBullish) =>
    if array.size(fvgs) > 0
        for i = 0 to array.size(fvgs) - 1
            fvg = array.get(fvgs, i)
            // Only render if within lookback window
            if bar_index - fvg.xLow <= lookbackBars or bar_index - fvg.xHigh <= lookbackBars
                prevUnmitigatedY = fvg.unmitigatedY == 0 ? (isBullish ? fvg.yHigh : fvg.yLow) : fvg.unmitigatedY
                if not fvg.mitigated
                    mitigatedY = isBullish ? low <= prevUnmitigatedY : high >= prevUnmitigatedY
                    if mitigatedY
                        fvg.unmitigatedY := isBullish ? low : high
                    fullyMitigated = isBullish ? fvg.unmitigatedY <= fvg.yLow : fvg.unmitigatedY >= fvg.yHigh
                    if fullyMitigated
                        fvg.mitigatedTime := time
                        fvg.mitigated := true
                        fvg.unmitigatedY := prevUnmitigatedY
                boxRightTime = time + (time - time[2])
                if na(fvg.fvgBox)
                    boxLeftTime = isBullish ? fvg.xLowTime : fvg.xHighTime
                    fillColor = color.new(boxColor, 80)
                    fvg.fvgBox := box.new(xloc = xloc.bar_time, left = boxLeftTime, right = boxRightTime, top = fvg.yHigh, bottom = fvg.yLow, border_color = fillColor, bgcolor = fillColor)
                else
                    box.set_right(fvg.fvgBox, fvg.mitigated ? fvg.mitigatedTime : boxRightTime)
                    if redrawFVGUnbalancedArea
                        if isBullish
                            box.set_top(fvg.fvgBox, fvg.unmitigatedY)
                        else
                            box.set_bottom(fvg.fvgBox, fvg.unmitigatedY)
                if removeMitigatedFVGDrawings and fvg.mitigated
                    box.delete(fvg.fvgBox)
                array.set(fvgs, i, fvg)

// === FVG DETECTION ===
if barstate.isconfirmed
    bisiFVG = high[2] < low
    sibiFVG = low[2] > high
    if bisiFVG
        bisi = FVG.new()
        bisi.xLow := bar_index[2]
        bisi.xHigh := bar_index
        bisi.xLowTime := time[2]
        bisi.xHighTime := time
        bisi.yLow := high[2]
        bisi.yHigh := low
        array.push(BISIs, bisi)
    if sibiFVG
        sibi = FVG.new()
        sibi.xLow := bar_index
        sibi.xHigh := bar_index[2]
        sibi.xLowTime := time
        sibi.xHighTime := time[2]
        sibi.yLow := high
        sibi.yHigh := low[2]
        array.push(SIBIs, sibi)
    cleanupFVGs(BISIs)
    cleanupFVGs(SIBIs)
    if showFVG
        renderFVGs(BISIs, fvgColor, true)
        renderFVGs(SIBIs, fvgColor, false)

// === SETTINGS: CISD (Change in State of Delivery) ===
inputGroupCISD = "CISD Settings"
showCISD = input.bool(true, "Show CISD", group=inputGroupCISD, tooltip="Toggle the display of Change in State of Delivery levels.")
showBullishCISD = input.bool(true, "Show Bullish CISD", group=inputGroupCISD, tooltip="Show bullish CISD levels (sweep lows, close above).")
showBearishCISD = input.bool(true, "Show Bearish CISD", group=inputGroupCISD, tooltip="Show bearish CISD levels (sweep highs, close below).")
cisdColor = input.color(#2962FF, "CISD Color", group=inputGroupCISD, tooltip="Color for CISD level lines.")
maxCISDs = input.int(10, "Max CISDs Displayed", minval=1, maxval=50, group=inputGroupCISD, tooltip="Maximum number of CISD levels to display.")
var int maxCISDPoints = 100

// === CISD TYPE & ARRAYS ===
type CISD
    // Reference to swept swing
    int swingIndex          // Index in swing array
    bool isBearish          // Direction of CISD
    
    // Order Block (sweep candle series)
    int startBar            // First candle in sweep series  
    int endBar              // Last candle in sweep series
    int startTime           // Time of first candle
    int endTime             // Time of last candle
    
    // CISD level and status
    float cisdLevel         // The opening price level
    int triggerBar          // When CISD was triggered
    int triggerTime         // Time of trigger
    bool isActive           // Is this CISD still valid
    
    // Visual elements
    line cisdLine = na      // The horizontal line

var CISD[] bullishCISDs = array.new<CISD>()
var CISD[] bearishCISDs = array.new<CISD>()

// === CISD HELPERS ===
cleanupCISDs(array<CISD> cisdArray) =>
    while array.size(cisdArray) > maxCISDPoints
        cisd = array.shift(cisdArray)
        if not na(cisd.cisdLine)
            line.delete(cisd.cisdLine)

// Check if current candle is upclose or downclose
isUpClose() => close > open
isDownClose() => close < open

// === CISD DETECTION ===
if barstate.isconfirmed and showCISD
    // Check for new CISDs based on swept swings
    
    // Check bearish CISDs (sweep highs, close below)
    if showBearishCISD and array.size(swingHighs) > 0
        for i = 0 to array.size(swingHighs) - 1
            swing = array.get(swingHighs, i)
            if swing.state == "swept" and swing.sweepX == bar_index[1]
                // This swing was just swept, look for potential CISD
                // Find the series of upclose candles that swept this high
                sweepStart = bar_index[1]
                sweepEnd = bar_index[1] 
                lowestOpen = open[1]
                
                // Look back to find start of upclose series
                lookback = 1
                while lookback <= 10 and bar_index - lookback >= 0
                    if close[lookback] > open[lookback] // upclose candle
                        sweepStart := bar_index[lookback]
                        lowestOpen := math.min(lowestOpen, open[lookback])
                        lookback += 1
                    else
                        break
                
                // Now check if current candle closes below the lowest open
                if isDownClose() and close < lowestOpen
                    // Create bearish CISD
                    cisd = CISD.new()
                    cisd.swingIndex := i
                    cisd.isBearish := true
                    cisd.startBar := sweepStart
                    cisd.endBar := sweepEnd
                    cisd.startTime := time[lookback-1]
                    cisd.endTime := time[1]
                    cisd.cisdLevel := lowestOpen
                    cisd.triggerBar := bar_index
                    cisd.triggerTime := time
                    cisd.isActive := true
                    array.push(bearishCISDs, cisd)
    
    // Check bullish CISDs (sweep lows, close above)  
    if showBullishCISD and array.size(swingLows) > 0
        for i = 0 to array.size(swingLows) - 1
            swing = array.get(swingLows, i)
            if swing.state == "swept" and swing.sweepX == bar_index[1]
                // This swing was just swept, look for potential CISD
                // Find the series of downclose candles that swept this low
                sweepStart = bar_index[1]
                sweepEnd = bar_index[1]
                highestOpen = open[1]
                
                // Look back to find start of downclose series
                lookback = 1
                while lookback <= 10 and bar_index - lookback >= 0
                    if close[lookback] < open[lookback] // downclose candle
                        sweepStart := bar_index[lookback]
                        highestOpen := math.max(highestOpen, open[lookback])
                        lookback += 1
                    else
                        break
                
                // Now check if current candle closes above the highest open
                if isUpClose() and close > highestOpen
                    // Create bullish CISD
                    cisd = CISD.new()
                    cisd.swingIndex := i
                    cisd.isBearish := false
                    cisd.startBar := sweepStart
                    cisd.endBar := sweepEnd
                    cisd.startTime := time[lookback-1]
                    cisd.endTime := time[1]
                    cisd.cisdLevel := highestOpen
                    cisd.triggerBar := bar_index
                    cisd.triggerTime := time
                    cisd.isActive := true
                    array.push(bullishCISDs, cisd)
    
    // Cleanup arrays
    cleanupCISDs(bullishCISDs)
    cleanupCISDs(bearishCISDs)

// === CISD RENDERING ===
renderCISDs(array<CISD> cisds, bool isBearish) =>
    if array.size(cisds) > 0
        visibleCount = 0
        for i = array.size(cisds) - 1 to 0
            if visibleCount >= maxCISDs
                break
            cisd = array.get(cisds, i)
            
            // Only render if within lookback window
            if bar_index - cisd.triggerBar <= lookbackBars
                if cisd.isActive
                    // Create or update CISD line
                    if na(cisd.cisdLine)
                        cisd.cisdLine := line.new(
                            x1=cisd.triggerBar, 
                            y1=cisd.cisdLevel, 
                            x2=bar_index, 
                            y2=cisd.cisdLevel, 
                            color=cisdColor, 
                            width=2, 
                            extend=extend.right, 
                            style=line.style_solid
                        )
                    else
                        line.set_x2(cisd.cisdLine, bar_index)
                    
                    array.set(cisds, i, cisd)
                    visibleCount += 1
            else
                // Remove old CISD lines
                if not na(cisd.cisdLine)
                    line.delete(cisd.cisdLine)
                    cisd.cisdLine := na
                    array.set(cisds, i, cisd)

// Render CISDs
if showCISD
    if showBearishCISD
        renderCISDs(bearishCISDs, true)
    if showBullishCISD  
        renderCISDs(bullishCISDs, false)